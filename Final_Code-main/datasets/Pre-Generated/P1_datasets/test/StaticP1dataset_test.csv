Query,Output
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""


def calculate_budget_remaining(budget_id):
""""""
Calculates the remaining budget for a given budget ID

Parameters:
    budget_id (str): The ID of the budget to calculate

Returns:
    float: The amount of remaining budget
""""""


def batch_update_task_status(task_ids, new_status):
""""""
Updates the status of multiple tasks in a batch operation

Parameters:
    task_ids (list): A list of task IDs whose status needs updating
    new_status (str): The new status to apply to the tasks

Returns:
    bool: True if the update was successful, False otherwise
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""


def list_department_members(department_id):
""""""
Returns a list of user IDs for all members within a specified department

Parameters:
    department_id (str): The ID of the department to list members for

Returns:
    list: User IDs of all the members in the department
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_report_from_data(dataset_id, report_type=""summary""):
""""""
Generates a specific type of report from a dataset

Parameters:
    dataset_id (str): The ID of the dataset from which to generate the report
    report_type (str): The type of report to generate, default is 'summary'

Returns:
    str: The ID of the generated report
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize all tickets that need a response and are associated with the ""MainframeMigration"" part.[/INST]","var_1 = search_object_by_name(query=""MainframeMigration"")
var_2 = works_list(applies_to_part=[var_1], ticket.needs_response=True, type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_info(contact_id, new_email=None, new_phone=None):
""""""
Updates the contact information for a given contact ID with new email and/or phone

Parameters:
    contact_id (str): The ID of the contact to update
    new_email (str, optional): The new email address; defaults to None
    new_phone (str, optional): The new phone number; defaults to None

Returns:
    bool: True if the update was successful; otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify my work items in 'development' stage, fetch similar items, and summarize them[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""development""], type=[""issue""])
var_3 = get_similar_work_items(work_id=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""


def generate_unique_identifier(prefix, use_timestamp=True):
""""""
Generates a unique identifier with an optional timestamp

Parameters:
    prefix (str): A prefix for the identifier
    use_timestamp (bool): If true, appends a timestamp to the prefix; defaults to True

Returns:
    str: The generated unique identifier
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Search for the latest sprint, get my tasks, and prepare a status report[/INST]","var_1 = get_sprint_id()
var_2 = who_am_i()
var_3 = works_list(owned_by=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def notify_user_of_overdue_tasks(user_id):
""""""
Notifies a user of any overdue tasks assigned to them

Parameters:
    user_id (str): The ID of the user to check for overdue tasks

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Organize my tasks according to their deadline and list them for today's planning meeting[/INST]","#Unanswerable_Invalid_Query_Error
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_ticket_comments(ticket_id):
""""""
Retrieves the comments attached to a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose comments are being retrieved

Returns:
    list: Comments associated with the ticket
""""""


def estimate_completion_time(task_id):
""""""
Estimates the completion time for a given task

Parameters:
    task_id (str): The ID of the task for which to estimate completion time

Returns:
    float: The estimated number of hours to complete the task
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""


def remove_users_from_group(user_ids, group_id):
""""""
Removes the specified users from a group

Parameters:
    user_ids (list): A list of user IDs to be removed from the group
    group_id (str): The ID of the group from which the users should be removed

Returns:
    bool: Status of the removal
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def filter_projects_by_status(project_ids, status=""active""):
""""""
Filters a list of project IDs by their status

Parameters:
    project_ids (list): A list of project IDs to filter
    status (str): The status to filter by, default is 'active'

Returns:
    list: Project IDs matching the status
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_work_left(project_id):
""""""
Calculates the estimated amount of work left in a project

Parameters:
    project_id (str): The ID of the project to calculate work for

Returns:
    float: Estimated hours of work left
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize all tasks related to part ENGINE-4 with a limit of 30 work items.[/INST]","var_1 = works_list(applies_to_part=[""ENGINE-4""], limit=30, type=[""task""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_budget_remaining(budget_id):
""""""
Calculates the remaining budget for a given budget ID

Parameters:
    budget_id (str): The ID of the budget to calculate

Returns:
    float: The amount of remaining budget
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_project_completion_rate(project_id):
""""""
Calculates the completion rate of tasks for a given project

Parameters:
    project_id (str): The ID of the project to calculate the completion rate for

Returns:
    float: The completion rate as a percentage
""""""


def calculate_time_until_deadline(work_item_id):
""""""
Calculates the amount of time remaining until the deadline of a work item

Parameters:
    work_item_id (str): The ID of the work item

Returns:
    float: The number of hours until the deadline
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def mark_ticket_for_review(ticket_id, reviewer_id):
""""""
Marks a ticket for review by a specific user

Parameters:
    ticket_id (str): The ID of the ticket to be marked for review
    reviewer_id (str): The ID of the user who should review the ticket

Returns:
    None
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_estimated_effort(work_id):
""""""
Calculates the estimated effort required to complete a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    float: Estimated effort in hours
""""""


def generate_unique_identifier(prefix, use_timestamp=True):
""""""
Generates a unique identifier with an optional timestamp

Parameters:
    prefix (str): A prefix for the identifier
    use_timestamp (bool): If true, appends a timestamp to the prefix; defaults to True

Returns:
    str: The generated unique identifier
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks related to CAPL-123 that need a response[/INST]","var_1 = who_am_i()
var_2 = works_list(applies_to_part=[""CAPL-123""], owned_by=[var_1], ticket.needs_response=True, type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""


def list_completed_tasks_by_user(user_id):
""""""
Lists all completed tasks for a specific user

Parameters:
    user_id (str): The ID of the user whose completed tasks need to be listed

Returns:
    list: List of completed task IDs
""""""


def mark_item_as_duplicated(work_item_id, duplicate_of_id):
""""""
Marks a work item as a duplicate of another

Parameters:
    work_item_id (str): The ID of the work item that is a duplicate
    duplicate_of_id (str): The ID of the work item of which it is a duplicate

Returns:
    bool: True if the item is successfully marked, False otherwise
""""""


def filter_tickets_by_date(ticket_ids, start_date, end_date=None):
""""""
Filters a list of ticket IDs based on a date range

Parameters:
    ticket_ids (list): A list of ticket IDs to filter
    start_date (str): The start date for the range
    end_date (str, optional): The end date for the range, defaults to None

Returns:
    list: Filtered list of ticket IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve the ID of the current user, list their tasks of type 'issue', then add any P2 priority issues to the current sprint.[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], issue.priority=[""p2""], type=[""issue""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List tasks in ""QA"" stage and add them to the sprint ""SPRINT-789""[/INST]","var_1 = works_list(stage.name=[""QA""], type=[""task""])
var_2 = add_work_items_to_sprint(work_ids=var_1, sprint_id=""SPRINT-789"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def archive_old_tickets(older_than_date, active_status=False):
""""""
Archives tickets that are older than the specified date, optionally filters by active status and returns the IDs

Parameters:
    older_than_date (str): A date in the format 'YYYY-MM-DD', to filter tickets older than this date
    active_status (bool): If True, only archives tickets that are currently active; defaults to False

Returns:
    str: ID of tickets archived
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify similar work items to ""ISSUE-999"" and prepare a summary[/INST]","var_1 = get_similar_work_items(work_id=""ISSUE-999"")
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def track_time_on_task(task_id, hours_spent):
""""""
Tracks time spent on a task by logging the number of hours

Parameters:
    task_id (str): The ID of the task on which time is spent
    hours_spent (float): The number of hours spent on the task

Returns:
    bool: Status of the time tracking
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def list_completed_tasks_by_user(user_id, project_id=None):
""""""
Lists all tasks completed by a given user, optionally filtered by project

Parameters:
    user_id (str): The ID of the user
    project_id (str, optional): The ID of the project to filter tasks

Returns:
    list: List of task IDs completed by the user
""""""


def get_user_permissions(user_id):
""""""
Returns a list of permissions for a specified user ID

Parameters:
    user_id (str): The ID of the user whose permissions you want to retrieve

Returns:
    list: User permissions
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def retrieve_user_permissions(user_id):
""""""
Retrieves the list of permissions for the specified user

Parameters:
    user_id (str): The ID of the user whose permissions are to be retrieved

Returns:
    list: The list of permissions for the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""


def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""


def check_availability_of_part(part_id):
""""""
Checks if a specific part is available in inventory

Parameters:
    part_id (str): The ID of the part to check for availability

Returns:
    bool: True if the part is available, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and list all tasks related to the marketing campaign with high urgency.[/INST]","var_1 = works_list(issue.priority=[""high""], type=[""task""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def batch_update_task_status(task_ids, new_status):
""""""
Updates the status of multiple tasks in a batch operation

Parameters:
    task_ids (list): A list of task IDs whose status needs updating
    new_status (str): The new status to apply to the tasks

Returns:
    bool: True if the update was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_item_as_duplicated(work_item_id, duplicate_of_id):
""""""
Marks a work item as a duplicate of another

Parameters:
    work_item_id (str): The ID of the work item that is a duplicate
    duplicate_of_id (str): The ID of the work item of which it is a duplicate

Returns:
    bool: True if the item is successfully marked, False otherwise
""""""


def fetch_ticket_history(ticket_id, history_limit=10):
""""""
Fetches the history of changes to a given ticket

Parameters:
    ticket_id (str): The ID of the ticket for which the history is requested
    history_limit (int): Maximum number of history entries to retrieve. The default is '10'

Returns:
    list: A list of history records for the ticket
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find tasks related to project 'Alpha' and assign them to the current sprint.[/INST]","var_1 = search_object_by_name(query=""Alpha"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def validate_project_completion(project_id):
""""""
Validates if all tasks within a project are completed

Parameters:
    project_id (str): The ID of the project to validate

Returns:
    bool: True if completed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def list_completed_items_by_user(user_id):
""""""
Lists items that have been completed by the given user

Parameters:
    user_id (str): The ID of the user whose completed items are being requested

Returns:
    list: Completed items by the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def retrieve_user_permissions(user_id):
""""""
Retrieves the list of permissions for the specified user

Parameters:
    user_id (str): The ID of the user whose permissions are to be retrieved

Returns:
    list: The list of permissions for the user
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all issues related to the ""DataSync"" project and generate action items for resolution[/INST]","var_1 = search_object_by_name(query=""DataSync"")
var_2 = works_list(type=[""issue""], applies_to_part=[var_1])
var_3 = create_actionable_tasks_from_text(text=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_contacts_by_organization(organization_id, active_only=True):
""""""
Returns a list of contacts associated with the specified organization, optionally filtering only active contacts

Parameters:
    organization_id (str): The ID of the organization to filter contacts
    active_only (bool): Flag to filter only active contacts, default value 'True'

Returns:
    list: Contacts associated with the organization
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def list_completed_items_by_user(user_id):
""""""
Lists items that have been completed by the given user

Parameters:
    user_id (str): The ID of the user whose completed items are being requested

Returns:
    list: Completed items by the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def create_report_for_sprint(sprint_id, report_type):
""""""
Generates a report for a given sprint

Parameters:
    sprint_id (str): The ID of the sprint
    report_type (str): The type of report to be generated

Returns:
    str: The ID of the generated report
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""
def retrieve_sprint_workload(sprint_id):
""""""
Calculates the total workload for a given sprint based on the work items associated with it

Parameters:
    sprint_id (str): The ID of the sprint for workload calculation

Returns:
    float: Total workload in hours
""""""


def filter_tickets_by_date(ticket_ids, start_date, end_date=None):
""""""
Filters a list of ticket IDs based on a date range

Parameters:
    ticket_ids (list): A list of ticket IDs to filter
    start_date (str): The start date for the range
    end_date (str, optional): The end date for the range, defaults to None

Returns:
    list: Filtered list of ticket IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Generate a list of tasks from the meeting notes E and assign them to the Engineering team with sprint id E-01[/INST]","var_1 = create_actionable_tasks_from_text(text=""E"")
var_2 = add_work_items_to_sprint(work_ids=var_1, sprint_id=""E-01"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_tasks_by_due_date(task_ids, due_date):
""""""
Filters tasks by their due date

Parameters:
    task_ids (list): A list of task IDs to filter
    due_date (str): The due date to filter tasks by

Returns:
    list: List of task IDs that have the specified due date
""""""



def find_work_items_by_tag(work_type, tag):
""""""
Finds work items of a certain type with a given tag

Parameters:
    work_type (str): The type of the work items to filter by
    tag (str): The tag to filter the work items

Returns:
    list: List of work items with the given tag
""""""


def calculate_budget_remaining(budget_id):
""""""
Calculates the remaining budget for a given budget ID

Parameters:
    budget_id (str): The ID of the budget to calculate

Returns:
    float: The amount of remaining budget
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_time_until_deadline(work_item_id):
""""""
Calculates the amount of time remaining until the deadline of a work item

Parameters:
    work_item_id (str): The ID of the work item

Returns:
    float: The number of hours until the deadline
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def get_recent_activity_log(user_id, limit=10):
""""""
Gets the most recent activity log entries for a given user

Parameters:
    user_id (str): The ID of the user to get activities for
    limit (int): The maximum number of activity log entries to return

Returns:
    list: Recent activity log entries
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""


def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items related to feature ""FEAT-999"" where I am the owner and summarize them.[/INST]","var_1 = who_am_i()
var_2 = works_list(applies_to_part=[""FEAT-999""], owned_by=[var_1], type=[""issue"", ""ticket"", ""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""


def fetch_user_created_work(user_id, work_type=None):
""""""
Retrieves work items created by a specific user

Parameters:
    user_id (str): The ID of the user whose work items are to be retrieved
    work_type (list): Filters for work of the provided types, e.g., ['issue', 'ticket']

Returns:
    list: Work items created by the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def get_user_permissions(user_id):
""""""
Returns a list of permissions for a specified user ID

Parameters:
    user_id (str): The ID of the user whose permissions you want to retrieve

Returns:
    list: User permissions
""""""


def estimate_task_duration(task_id, complexity_level):
""""""
Estimates the duration needed to complete a task based on its complexity level

Parameters:
    task_id (str): The ID of the task
    complexity_level (str): The complexity level of the task. Allowed values: 'low', 'medium', 'high'

Returns:
    float: Estimated duration in hours
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def extract_contact_info(text_id, entity_type):
""""""
Extracts contact information from a text source based on a given entity type

Parameters:
    text_id (str): The ID of the text source from which to extract contact information
    entity_type (str): The type of entity to extract info from. Allowed values: 'individual', 'company'

Returns:
    list: Extracted contact information
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        How do I change a flat tire on my bicycle?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_user_contact_info(user_id):
""""""
Retrieves contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact information is requested

Returns:
    str: The contact information of the user
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def assign_tasks_to_user(task_ids, user_id):
""""""
Assigns a list of task IDs to the provided user

Parameters:
    task_ids (list): List of task IDs to be assigned
    user_id (str): The ID of the user to whom the tasks will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def list_completed_tasks_by_user(user_id):
""""""
Lists all completed tasks for a specific user

Parameters:
    user_id (str): The ID of the user whose completed tasks need to be listed

Returns:
    list: List of completed task IDs
""""""


def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""


def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""


def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What if every decision we make creates a parallel universe with a different outcome?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""


def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_task_dependencies(task_id):
""""""
Returns a list of task IDs that are dependencies for the given task

Parameters:
    task_id (str): The ID of the task for which dependencies are requested

Returns:
    list: Dependency task IDs
""""""


def generate_work_report(work_ids):
""""""
Generates a report for the given work items.

Parameters:
    work_ids (list): A list of work item IDs for report generation

Returns:
    str: The ID of the generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find tasks associated with the project ""ProjectX"" and summarize them and prioritiize them[/INST]","var_1 = search_object_by_name(query=""ProjectX"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = summarize_objects(objects=var_2)
var_4 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def validate_object_existence(object_id):
""""""
Checks if an object with the given ID exists in the system

Parameters:
    object_id (str): The ID of the object to check

Returns:
    bool: True if the object exists, otherwise False
""""""


def assign_tasks_to_employee(task_ids, employee_id):
""""""
Assigns a list of tasks to the specified employee

Parameters:
    task_ids (list): A list of task IDs to be assigned
    employee_id (str): The ID of the employee to whom the tasks will be assigned

Returns:
    bool: True if the assignment was successful, False otherwise
""""""


def fetch_user_created_work(user_id, work_type=None):
""""""
Retrieves work items created by a specific user

Parameters:
    user_id (str): The ID of the user whose work items are to be retrieved
    work_type (list): Filters for work of the provided types, e.g., ['issue', 'ticket']

Returns:
    list: Work items created by the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def calculate_estimate_completion_time(work_id):
""""""
Calculates the estimated completion time for the specified work item

Parameters:
    work_id (str): The ID of the work item to calculate the estimated time

Returns:
    float: Estimated completion time in hours
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_object_history(object_id):
""""""
Retrieves the change history of a specified object

Parameters:
    object_id (str): The ID of the object for which history is requested

Returns:
    list: A list of changes made to the object
""""""


def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""


def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize tasks related to project Alpha under stage 'development'
[/INST]","var_1 = search_object_by_name(query=""Alpha"")
var_2 = works_list(applies_to_part=[var_1], stage.name=[""development""], type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def validate_object_existence(object_id):
""""""
Checks if an object with the given ID exists in the system

Parameters:
    object_id (str): The ID of the object to check

Returns:
    bool: True if the object exists, otherwise False
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_progress_percentage(project_id):
""""""
Calculates the progress percentage of the given project

Parameters:
    project_id (str): The ID of the project for which to calculate progress

Returns:
    float: The percentage of project completion
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def assign_tickets_to_user(ticket_ids, user_id):
""""""
Assigns a set of tickets to a specified user

Parameters:
    ticket_ids (list): A list of ticket IDs to be assigned
    user_id (str): The ID of the user to whom the tickets will be assigned

Returns:
    None
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_project_timeline(project_id):
""""""
Retrieves the timeline and key milestones of a project

Parameters:
    project_id (str): The ID of the project for which the timeline is requested

Returns:
    list: Key milestones and dates for the project timeline
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Get similar work items for issue PROJ-101, summarize and prioritize them, then add them to the ongoing sprint[/INST]","var_1 = get_similar_work_items(work_id=""PROJ-101"")
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_1)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def delete_objects_by_id(object_ids):
""""""
Deletes objects from the system based on their IDs

Parameters:
    object_ids (list): List of object IDs to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_work_item_history(work_id):
""""""
Retrieves the history of changes for a given work item

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: A chronological list of changes made to the work item
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Fetch my tickets, summarize and arrange them by urgency.[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""


def calculate_time_until_deadline(work_item_id):
""""""
Calculates the amount of time remaining until the deadline of a work item

Parameters:
    work_item_id (str): The ID of the work item

Returns:
    float: The number of hours until the deadline
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and prioritize my works of type 'issue' that are pending in 'QA' stage[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""QA""], type=[""issue""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_tasks_by_due_date(task_ids, due_date):
""""""
Filters tasks by their due date

Parameters:
    task_ids (list): A list of task IDs to filter
    due_date (str): The due date to filter tasks by

Returns:
    list: List of task IDs that have the specified due date
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_estimate_completion_time(work_id):
""""""
Calculates the estimated completion time for the specified work item

Parameters:
    work_id (str): The ID of the work item to calculate the estimated time

Returns:
    float: Estimated completion time in hours
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create tasks from insights extracted from the text ""Update server configurations"" and prioritize them[/INST]","var_1 = create_actionable_tasks_from_text(text=""Update server configurations"")
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def schedule_meeting_with_user(user_id, duration=30, urgent=False):
""""""
Schedules a meeting with a specified user

Parameters:
    user_id (str): The ID of the user with whom to schedule a meeting
    duration (int): Duration of the meeting in minutes, default is '30'
    urgent (bool): Whether the meeting is urgent, defaults to False

Returns:
    str: The ID of the scheduled meeting
""""""
def update_issue_status(issue_id, new_status):
""""""
Updates the status of an issue

Parameters:
    issue_id (str): The ID of the issue to be updated
    new_status (str): The new status to be set for the issue. Allowed values: open, in_progress, resolved, closed

Returns:
    bool: True if the update was successful, False otherwise
""""""


def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""


def validate_project_completion(project_id):
""""""
Validates if all tasks within a project are completed

Parameters:
    project_id (str): The ID of the project to validate

Returns:
    bool: True if completed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""


def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_info(contact_id, new_email=None, new_phone=None):
""""""
Updates the contact information for a given contact ID with new email and/or phone

Parameters:
    contact_id (str): The ID of the contact to update
    new_email (str, optional): The new email address; defaults to None
    new_phone (str, optional): The new phone number; defaults to None

Returns:
    bool: True if the update was successful; otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Filter issues requiring a response for Rev organization REV-456 and organize by stage[/INST]","var_1 = search_object_by_name(query=""REV-456"")
var_2 = works_list(issue.rev_orgs=[var_1], ticket.needs_response=True, type=[""issue""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def validate_user_permissions(user_id, required_permissions):
""""""
Checks if the user has the specified permissions

Parameters:
    user_id (str): The ID of the user whose permissions need to be checked
    required_permissions (list): A list of permissions to check against the user's permissions

Returns:
    bool: True if the user has all the required permissions, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""


def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks and add the p0-priority ones to the current sprint[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_progress_report(project_id, report_format=""summary""):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which the progress report is needed
    report_format (str): The format of the report; 'summary' or 'detailed'. The default is 'summary'

Returns:
    str: The generated progress report
""""""


def link_related_objects(object_id, related_object_id):
""""""
Creates a link between two related objects in the system

Parameters:
    object_id (str): The ID of the primary object
    related_object_id (str): The ID of the object to relate to the primary

Returns:
    bool: True if the objects were successfully linked, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def check_ticket_status(ticket_id):
""""""
Checks the status of a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose status is to be checked

Returns:
    str: The status of the ticket
""""""


def filter_contacts_by_organization(organization_id, active_only=True):
""""""
Returns a list of contacts associated with the specified organization, optionally filtering only active contacts

Parameters:
    organization_id (str): The ID of the organization to filter contacts
    active_only (bool): Flag to filter only active contacts, default value 'True'

Returns:
    list: Contacts associated with the organization
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find tasks related to project Alpha and sort them by priority[/INST]","var_1 = search_object_by_name(query=""Alpha"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def mark_ticket_for_review(ticket_id, reviewer_id):
""""""
Marks a ticket for review by a specific user

Parameters:
    ticket_id (str): The ID of the ticket to be marked for review
    reviewer_id (str): The ID of the user who should review the ticket

Returns:
    None
""""""


def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Extract actionable tasks from meeting notes ""M"" and assign them to developer DEV-ID-456[/INST]","var_1 = create_actionable_tasks_from_text(text=""M"")
var_2 = add_work_items_to_sprint(work_ids=var_1, sprint_id=""DEV-ID-456"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all issues related to part ENH-456 and list them by priority[/INST]","var_1 = works_list(applies_to_part=[""ENH-456""], type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""


def track_time_on_task(task_id, hours_spent):
""""""
Tracks time spent on a task by logging the number of hours

Parameters:
    task_id (str): The ID of the task on which time is spent
    hours_spent (float): The number of hours spent on the task

Returns:
    bool: Status of the time tracking
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize tickets with 'low' severity that are unresolved[/INST]","var_1 = works_list(ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find tickets related to the 'frontend' part with 'low' severity and order them by priority[/INST]","var_1 = search_object_by_name(query=""frontend"")
var_2 = works_list(applies_to_part=[var_1], ticket.severity=[""low""], type=[""ticket""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def check_ticket_status(ticket_id):
""""""
Checks the status of a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose status is to be checked

Returns:
    str: The status of the ticket
""""""


def remove_object_from_inventory(object_id):
""""""
Removes an object from the inventory system based on the object ID

Parameters:
    object_id (str): The ID of the object to remove from inventory

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def calculate_project_completion_rate(project_id):
""""""
Calculates the completion rate of tasks for a given project

Parameters:
    project_id (str): The ID of the project to calculate the completion rate for

Returns:
    float: The completion rate as a percentage
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_estimated_effort(work_id):
""""""
Calculates the estimated effort required to complete a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    float: Estimated effort in hours
""""""


def fetch_ticket_history(ticket_id, history_limit=10):
""""""
Fetches the history of changes to a given ticket

Parameters:
    ticket_id (str): The ID of the ticket for which the history is requested
    history_limit (int): Maximum number of history entries to retrieve. The default is '10'

Returns:
    list: A list of history records for the ticket
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all tasks related to the ""Backend"" part and sort them by priority[/INST]","var_1 = search_object_by_name(query=""Backend"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and add any P2 tasks I own to the current sprint[/INST]","var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p2""], owned_by=[var_1], type=[""task""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def remove_user_from_project(user_id, project_id):
""""""
Removes a user from a project

Parameters:
    user_id (str): The ID of the user to be removed
    project_id (str): The ID of the project from which the user is to be removed

Returns:
    bool: True if the user is successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def link_related_documents(doc_id, related_doc_ids):
""""""
Links related documents to the given document in the system

Parameters:
    doc_id (str): The ID of the document to which related documents should be linked
    related_doc_ids (list): A list of IDs for related documents

Returns:
    bool: True if the operation was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Extract actionable tasks from a document titled ""Project Roadmap"" and prioritize the resulting tasks.[/INST]","var_1 = create_actionable_tasks_from_text(text=""Project Roadmap"")
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_user_permissions(user_id):
""""""
Lists all the permissions that a user has within the system

Parameters:
    user_id (str): The ID of the user for whom permissions are being listed

Returns:
    list: A list of permissions that the user possesses
""""""


def fetch_users_from_group(group_id):
""""""
Retrieves a list of user IDs that belong to the specified group

Parameters:
    group_id (str): The ID of the group

Returns:
    list: User IDs belonging to the group
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_work_item_history(work_id):
""""""
Retrieves the history of changes for a given work item

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: A chronological list of changes made to the work item
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add P2 issues from REV organization to sprint[/INST]","var_1 = search_object_by_name(query=""REV organization"")
var_2 = get_sprint_id()
var_3 = works_list(issue.priority=[""p2""], issue.rev_orgs=[var_1], type=[""issue""])
var_4 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize and prioritize tasks for the 'frontend' team under the 'design' stage[/INST]","var_1 = works_list(owned_by=[""frontend""], stage.name=[""design""], type=[""task""])
var_2 = prioritize_objects(objects=var_1)
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_data(report_type, data_set_id):
""""""
Generates report data based on the provided report type and data set

Parameters:
    report_type (str): The type of report to generate
    data_set_id (str): The ID of the data set to be used for the report

Returns:
    str: A report data string or ID depending on internal implementation
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def assign_issues_to_user(issue_ids, user_id):
""""""
Assigns a list of issues to the specified user

Parameters:
    issue_ids (list): A list of issue IDs that need to be assigned
    user_id (str): The user ID to whom the issues will be assigned

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_estimated_effort(work_id):
""""""
Calculates the estimated effort required to complete a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    float: Estimated effort in hours
""""""


def generate_work_report(work_ids):
""""""
Generates a report for the given work items.

Parameters:
    work_ids (list): A list of work item IDs for report generation

Returns:
    str: The ID of the generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize tasks related to the 'Backend' part that need a response[/INST]","var_1 = search_object_by_name(query=""Backend"")
var_2 = works_list(type=[""task""], applies_to_part=[var_1], ticket.needs_response=True)
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize and summarize tasks owned by ProjectManager in the PLANNING stage and limit the number of work items to 28.[/INST]","var_1 = works_list(owned_by=[""ProjectManager""], stage.name=[""PLANNING""], type=[""task""], limit=28)
var_2 = prioritize_objects(objects=var_1)
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Search for work items by user USER-XYZ, filter by tasks, and return a prioritized list[/INST]","var_1 = search_object_by_name(query=""USER-XYZ"")
var_2 = works_list(created_by=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def retrieve_document_by_keyword(keyword):
""""""
Retrieves a document ID containing the specified keyword

Parameters:
    keyword (str): The keyword to search for in the documents

Returns:
    str: ID of the document containing the keyword
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Get the current sprint ID, look up work items by type 'ticket' for user DEVU-456, and add them to the sprint.[/INST]","var_1 = get_sprint_id()
var_2 = works_list(created_by=[""DEVU-456""], type=[""ticket""])
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_user_contact_info(user_id):
""""""
Retrieves contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact information is requested

Returns:
    str: The contact information of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize the list of issues under ""Backend"" part and then summarize them[/INST]","var_1 = works_list(applies_to_part=[""Backend""], type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_work_left(project_id):
""""""
Calculates the estimated amount of work left in a project

Parameters:
    project_id (str): The ID of the project to calculate work for

Returns:
    float: Estimated hours of work left
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find my issues related to Rev organization REV-321 and summarize them[/INST]","var_1 = who_am_i()
var_2 = works_list(issue.rev_orgs=[""REV-321""], owned_by=[var_1], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""


def convert_task_to_ticket(task_id):
""""""
Converts a task into a ticket in the system

Parameters:
    task_id (str): The ID of the task to be converted

Returns:
    str: The ID of the newly created ticket
""""""


def validate_project_completion(project_id):
""""""
Validates if all tasks within a project are completed

Parameters:
    project_id (str): The ID of the project to validate

Returns:
    bool: True if completed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_user_workload(user_id):
""""""
Calculates the workload of a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be calculated

Returns:
    float: The calculated workload value
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_sprint_history(sprint_id):
""""""
Retrieves the change history of a sprint

Parameters:
    sprint_id (str): The ID of the ticket

Returns:
    list: A list of changes made to the sprint
""""""


def check_inventory_availability(part_id, minimum_quantity=1):
""""""
Checks if the inventory has the specified part in at least the minimum quantity

Parameters:
    part_id (str): The ID of the part to check in inventory
    minimum_quantity (int): The minimum quantity to check for; defaults to 1

Returns:
    bool: True if the minimum quantity is available; otherwise False
""""""


def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find tasks related to ""ZetaProject"", prioritize, and summarize for reporting[/INST]","var_1 = search_object_by_name(query=""ZetaProject"")
var_2 = works_list(type=[""task""], ticket.rev_org=[var_1])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_sprint_history(sprint_id):
""""""
Retrieves the change history of a sprint

Parameters:
    sprint_id (str): The ID of the ticket

Returns:
    list: A list of changes made to the sprint
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Determine my current sprint and list all tickets that need a response, then add p0 priority issues to the sprint[/INST]","var_1 = who_am_i()
var_2 = get_sprint_id()
var_3 = works_list(ticket.needs_response=True, type=[""ticket""])
var_4 = works_list(issue.priority=[""p0""], type=[""issue""])
var_5 = add_work_items_to_sprint(work_ids=var_4, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def track_time_on_task(task_id, hours_spent):
""""""
Tracks time spent on a task by logging the number of hours

Parameters:
    task_id (str): The ID of the task on which time is spent
    hours_spent (float): The number of hours spent on the task

Returns:
    bool: Status of the time tracking
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def filter_users_by_department(department_id=None, active_only=False):
""""""
Filters a list of users that belong to the specified department

Parameters:
    department_id (str): The ID of the department to filter users
    active_only (bool): Filters for only active users if set to True

Returns:
    list: Users in the specified department
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items created by user ID 'USER-789', summarize, and add to sprint with ID SPRINT-321[/INST]","var_1 = works_list(created_by=[""USER-789""], type=[""issue"", ""ticket"", ""task""])
var_2 = summarize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=""SPRINT-321"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_contact_info(user_id):
""""""
Retrieves the contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact info is requested

Returns:
    str: Contact information of the user
""""""


def find_work_items_by_tag(work_type, tag):
""""""
Finds work items of a certain type with a given tag

Parameters:
    work_type (str): The type of the work items to filter by
    tag (str): The tag to filter the work items

Returns:
    list: List of work items with the given tag
""""""


def convert_task_to_subtask(task_id, parent_task_id):
""""""
Converts a standalone task into a subtask of another task

Parameters:
    task_id (str): The ID of the task to be converted
    parent_task_id (str): The ID of the parent task to which the subtask will be linked

Returns:
    bool: True if the conversion was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def fetch_ticket_history(ticket_id, history_limit=10):
""""""
Fetches the history of changes to a given ticket

Parameters:
    ticket_id (str): The ID of the ticket for which the history is requested
    history_limit (int): Maximum number of history entries to retrieve. The default is '10'

Returns:
    list: A list of history records for the ticket
""""""


def check_availability_of_part(part_id):
""""""
Checks if a specific part is available in inventory

Parameters:
    part_id (str): The ID of the part to check for availability

Returns:
    bool: True if the part is available, False otherwise
""""""


def filter_tickets_by_date(ticket_ids, start_date, end_date=None):
""""""
Filters a list of ticket IDs based on a date range

Parameters:
    ticket_ids (list): A list of ticket IDs to filter
    start_date (str): The start date for the range
    end_date (str, optional): The end date for the range, defaults to None

Returns:
    list: Filtered list of ticket IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize tickets from 'phone' channel for Rev organization REV-789[/INST]","var_1 = works_list(ticket.rev_org=[""REV-789""], ticket.source_channel=[""phone""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def estimate_ticket_resolution_time(ticket_id):
""""""
Estimates the resolution time for a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to estimate time for

Returns:
    float: Estimated time in hours to resolve the ticket
""""""


def validate_user_permissions(user_id, required_permissions):
""""""
Checks if the user has the specified permissions

Parameters:
    user_id (str): The ID of the user whose permissions need to be checked
    required_permissions (list): A list of permissions to check against the user's permissions

Returns:
    bool: True if the user has all the required permissions, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def list_completed_tasks_by_user(user_id, project_id=None):
""""""
Lists all tasks completed by a given user, optionally filtered by project

Parameters:
    user_id (str): The ID of the user
    project_id (str, optional): The ID of the project to filter tasks

Returns:
    list: List of task IDs completed by the user
""""""


def get_user_permissions(user_id):
""""""
Returns a list of permissions for a specified user ID

Parameters:
    user_id (str): The ID of the user whose permissions you want to retrieve

Returns:
    list: User permissions
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_project_summary(project_id):
""""""
Generates a summary report for the specified project

Parameters:
    project_id (str): The ID of the project to summarize

Returns:
    str: A summary report of the project
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_task_dependencies(task_id):
""""""
Returns a list of task IDs that are dependencies for the given task

Parameters:
    task_id (str): The ID of the task for which dependencies are requested

Returns:
    list: Dependency task IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def merge_duplicate_tickets(primary_ticket_id, duplicate_ticket_ids):
""""""
Merges duplicate tickets into a primary ticket

Parameters:
    primary_ticket_id (str): The ID of the primary ticket that remains
    duplicate_ticket_ids (list): The IDs of the duplicate tickets to be merged into the primary

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List all p2 tickets, get similar work items, and prioritize them.[/INST]","var_1 = works_list(issue.priority=[""p2""], type=[""ticket""])
var_2 = get_similar_work_items(work_id=var_1)
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List work items created by user 'USER-XYZ' and sort them by priority[/INST]","var_1 = search_object_by_name(query=""USER-XYZ"")
var_2 = works_list(created_by=[var_1], type=[""issue"", ""ticket"", ""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Get the current sprint ID and add work items from the CAPL-456 part to it[/INST]","var_1 = search_object_by_name(query=""CAPL-456"")
var_2 = works_list(applies_to_part=[var_1], type=[""issue"", ""ticket"", ""task""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""

def fetch_user_tasks(user_id, include_completed=False):
""""""
Retrieves a list of tasks assigned to a user

Parameters:
    user_id (str): The ID of the user whose tasks are to be fetched
    include_completed (bool): Whether to include completed tasks in the list

Returns:
    list: List of tasks assigned to the user
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my completed issues and extract actionable items.[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""completed""], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
var_4 = create_actionable_tasks_from_text(text=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def assign_tasks_to_user(task_ids, user_id):
""""""
Assigns a list of task IDs to the provided user

Parameters:
    task_ids (list): List of task IDs to be assigned
    user_id (str): The ID of the user to whom the tasks will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_stage_of_work_item(work_item_id, new_stage):
""""""
Updates the stage of a work item

Parameters:
    work_item_id (str): The ID of the work item to update
    new_stage (str): The new stage to which the work item should be moved

Returns:
    bool: True if the stage is successfully updated, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_user_workload(user_id):
""""""
Calculates the workload of a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be calculated

Returns:
    float: The calculated workload value
""""""


def set_user_permission(user_id, permission_level):
""""""
Sets a specific permission level for a user account

Parameters:
    user_id (str): The ID of the user to set permissions for
    permission_level (str): The level of permission to assign e.g., 'read', 'write', 'admin'

Returns:
    bool: True if the permission was set successfully, False otherwise
""""""


def generate_work_report(work_ids):
""""""
Generates a report for the given work items.

Parameters:
    work_ids (list): A list of work item IDs for report generation

Returns:
    str: The ID of the generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and list tasks related to billing issues, then prioritize this list[/INST]","var_1 = works_list(type=[""task""], type=[""billing""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tickets with ""medium"" severity and response needed[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], ticket.severity=[""medium""], ticket.needs_response=True, type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def remove_work_item_from_sprint(work_id, sprint_id):
""""""
Removes the specified work item from a sprint

Parameters:
    work_id (str): The ID of the work item to be removed
    sprint_id (str): The ID of the sprint from which to remove the work item

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and prioritize P1 tickets related to Rev organization ORG-101[/INST]","var_1 = works_list(issue.priority=[""p1""], ticket.rev_org=[""ORG-101""], type=[""ticket""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Assign new tasks from the text file T to the current sprint[/INST]","var_1 = create_actionable_tasks_from_text(text=""T"")
var_2 = get_sprint_id()
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def validate_object_existence(object_id):
""""""
Checks if an object with the given ID exists in the system

Parameters:
    object_id (str): The ID of the object to check

Returns:
    bool: True if the object exists, otherwise False
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def assign_ticket_to_user(ticket_id, user_id):
""""""
Assigns a specific ticket to a user

Parameters:
    ticket_id (str): The ID of the ticket to be assigned
    user_id (str): The ID of the user to whom the ticket will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""


def calculate_effort_for_task(task_id):
""""""
Calculates the effort spent on a specific task by summing subtasks

Parameters:
    task_id (str): The ID of the task for which the effort needs to be calculated

Returns:
    float: Total effort spent on the task
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def archive_completed_tasks(project_id, completed_since):
""""""
Archives tasks that are completed within the given project since the specified time

Parameters:
    project_id (str): The ID of the project containing the tasks
    completed_since (str): Archive tasks completed after this timestamp

Returns:
    int: Number of tasks archived
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_project_summary(project_id):
""""""
Generates a summary report for the specified project

Parameters:
    project_id (str): The ID of the project to summarize

Returns:
    str: A summary report of the project
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extract_contact_info(text_id, entity_type):
""""""
Extracts contact information from a text source based on a given entity type

Parameters:
    text_id (str): The ID of the text source from which to extract contact information
    entity_type (str): The type of entity to extract info from. Allowed values: 'individual', 'company'

Returns:
    list: Extracted contact information
""""""


def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize tickets from channel 'email' for part PROD-789 and get current user's ID[/INST]","var_1 = search_object_by_name(query=""PROD-789"")
var_2 = works_list(ticket.source_channel=[""email""], applies_to_part=[var_1], type=[""ticket""])
var_3 = prioritize_objects(objects=var_2)
var_4 = who_am_i()
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""


def calculate_expense_totals(expense_ids):
""""""
Calculates the total amount from a list of expense IDs

Parameters:
    expense_ids (list): List of expense IDs to calculate the total amount

Returns:
    float: The total amount of the expenses
""""""
def link_issues_to_project(issue_ids, project_id):
""""""
Links the given issues to the specified project

Parameters:
    issue_ids (list): A list of issue IDs to be linked to the project
    project_id (str): The ID of the project to which the issues should be linked

Returns:
    bool: Status of the linking action
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_status(work_item_id, status_options):
""""""
Checks if the given work item has a status that is among the provided options

Parameters:
    work_item_id (str): The ID of the work item to check
    status_options (list): A list of valid status options

Returns:
    bool: True if status is valid, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize and prioritize tickets from the social media channel for better customer engagement[/INST]","var_1 = works_list(ticket.source_channel=[""social media""], type=[""ticket""])
var_2 = prioritize_objects(objects=var_1)
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_tasks_by_due_date(task_ids, due_date):
""""""
Filters tasks by their due date

Parameters:
    task_ids (list): A list of task IDs to filter
    due_date (str): The due date to filter tasks by

Returns:
    list: List of task IDs that have the specified due date
""""""



def remove_user_from_project(user_id, project_id):
""""""
Removes a user from a project

Parameters:
    user_id (str): The ID of the user to be removed
    project_id (str): The ID of the project from which the user is to be removed

Returns:
    bool: True if the user is successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def find_user_by_email(email):
""""""
Finds a user in the system by their email address

Parameters:
    email (str): The email address of the user to find

Returns:
    str: ID of the user
""""""


def remove_object_from_inventory(object_id):
""""""
Removes an object from the inventory system based on the object ID

Parameters:
    object_id (str): The ID of the object to remove from inventory

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def filter_records_by_date(record_ids, start_date, end_date):
""""""
Filters a list of record IDs based on a date range

Parameters:
    record_ids (list): List of record IDs to filter
    start_date (str): Start date for the filtering in 'YYYY-MM-DD' format
    end_date (str): End date for the filtering in 'YYYY-MM-DD' format

Returns:
    list: Filtered record IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def generate_unique_identifier(prefix, use_timestamp=True):
""""""
Generates a unique identifier with an optional timestamp

Parameters:
    prefix (str): A prefix for the identifier
    use_timestamp (bool): If true, appends a timestamp to the prefix; defaults to True

Returns:
    str: The generated unique identifier
""""""


def generate_progress_report(project_id):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which to generate the report

Returns:
    str: A string summary of the project's progress report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize and add to the current sprint all tickets that need a response from the customer 'BigEnterprises'[/INST]","var_1 = search_object_by_name(query=""BigEnterprises"")
var_2 = works_list(ticket.rev_org=[var_1], ticket.needs_response=True, type=[""ticket""])
var_3 = prioritize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For 'FEATURE-321' tagged issues, filter out the high priority ones and get a summary for a quick review.[/INST]","var_1 = search_object_by_name(query=""FEATURE-321"")
var_2 = works_list(applies_to_part=[var_1], issue.priority=[""high""], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def update_issue_status(issue_id, new_status):
""""""
Updates the status of an issue

Parameters:
    issue_id (str): The ID of the issue to be updated
    new_status (str): The new status to be set for the issue. Allowed values: open, in_progress, resolved, closed

Returns:
    bool: True if the update was successful, False otherwise
""""""


def estimate_completion_time(task_id):
""""""
Estimates the completion time for a given task

Parameters:
    task_id (str): The ID of the task for which to estimate completion time

Returns:
    float: The estimated number of hours to complete the task
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""


def mark_item_as_duplicated(work_item_id, duplicate_of_id):
""""""
Marks a work item as a duplicate of another

Parameters:
    work_item_id (str): The ID of the work item that is a duplicate
    duplicate_of_id (str): The ID of the work item of which it is a duplicate

Returns:
    bool: True if the item is successfully marked, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items of type 'task' under REV-321, summarize and add to sprint 555[/INST]","var_1 = works_list(owned_by=[""REV-321""], type=[""task""])
var_2 = summarize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=""555"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def check_inventory_availability(part_id, minimum_quantity=1):
""""""
Checks if the inventory has the specified part in at least the minimum quantity

Parameters:
    part_id (str): The ID of the part to check in inventory
    minimum_quantity (int): The minimum quantity to check for; defaults to 1

Returns:
    bool: True if the minimum quantity is available; otherwise False
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve work items related to the CAPL-999 part and create tasks from their summary[/INST]","var_1 = works_list(applies_to_part=[""CAPL-999""])
var_2 = summarize_objects(objects=var_1)
var_3 = create_actionable_tasks_from_text(text=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def merge_duplicate_records(primary_record_id, duplicate_record_id):
""""""
Merges a duplicate record into a primary record

Parameters:
    primary_record_id (str): The ID of the primary record to keep
    duplicate_record_id (str): The ID of the duplicate record to merge

Returns:
    bool: True if the merge was successful; otherwise False
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_project_summary(project_id):
""""""
Generates a summary report for the specified project

Parameters:
    project_id (str): The ID of the project to summarize

Returns:
    str: A summary report of the project
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_object_history(object_id):
""""""
Retrieves the change history of a specified object

Parameters:
    object_id (str): The ID of the object for which history is requested

Returns:
    list: A list of changes made to the object
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks that need a response and are in 'development' stage[/INST]","var_1 = who_am_i()
var_2 = works_list(type=[""task""], owned_by=[var_1], ticket.needs_response=True, stage.name=[""development""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a specific date range

Parameters:
    start_date (str): The start date for the filter range (format: YYYY-MM-DD)
    end_date (str): The end date for the filter range (format: YYYY-MM-DD)
    work_type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Work items in the specified date range
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What if time is not a linear progression but a complex web of interconnected moments?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""


def fetch_users_from_group(group_id):
""""""
Retrieves a list of user IDs that belong to the specified group

Parameters:
    group_id (str): The ID of the group

Returns:
    list: User IDs belonging to the group
""""""


def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_object_history(object_id):
""""""
Retrieves the change history of a specified object

Parameters:
    object_id (str): The ID of the object for which history is requested

Returns:
    list: A list of changes made to the object
""""""


def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""
def retrieve_sprint_workload(sprint_id):
""""""
Calculates the total workload for a given sprint based on the work items associated with it

Parameters:
    sprint_id (str): The ID of the sprint for workload calculation

Returns:
    float: Total workload in hours
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all issues created by DEVU-456 and return a prioritized list[/INST]","var_1 = works_list(created_by=[""DEVU-456""], type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_user_contact_info(user_id):
""""""
Retrieves contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact information is requested

Returns:
    str: The contact information of the user
""""""


def find_user_by_email(email):
""""""
Finds a user in the system by their email address

Parameters:
    email (str): The email address of the user to find

Returns:
    str: ID of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize and summarize my tasks[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_ticket_comments(ticket_id):
""""""
Retrieves the comments attached to a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose comments are being retrieved

Returns:
    list: Comments associated with the ticket
""""""


def link_related_objects(object_id, related_object_id):
""""""
Creates a link between two related objects in the system

Parameters:
    object_id (str): The ID of the primary object
    related_object_id (str): The ID of the object to relate to the primary

Returns:
    bool: True if the objects were successfully linked, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_contacts_by_organization(organization_id, active_only=True):
""""""
Returns a list of contacts associated with the specified organization, optionally filtering only active contacts

Parameters:
    organization_id (str): The ID of the organization to filter contacts
    active_only (bool): Flag to filter only active contacts, default value 'True'

Returns:
    list: Contacts associated with the organization
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def get_user_workload(user_id):
""""""
Determines the current workload for a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be determined

Returns:
    int: The number of tasks assigned to the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and list issues in 'QA' stage for current user[/INST]","var_1 = who_am_i()
var_2 = works_list(stage.name=[""QA""], owned_by=[var_1], type=[""issue""])
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Provide a prioritized list of all tasks that need a response and are created by user USER-321[/INST]","var_1 = works_list(created_by=[""USER-321""], ticket.needs_response=True, type=[""task""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def find_work_items_by_tag(work_type, tag):
""""""
Finds work items of a certain type with a given tag

Parameters:
    work_type (str): The type of the work items to filter by
    tag (str): The tag to filter the work items

Returns:
    list: List of work items with the given tag
""""""


def get_ticket_comments(ticket_id):
""""""
Retrieves the comments attached to a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose comments are being retrieved

Returns:
    list: Comments associated with the ticket
""""""
def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_user_permissions(user_id):
""""""
Lists all the permissions that a user has within the system

Parameters:
    user_id (str): The ID of the user for whom permissions are being listed

Returns:
    list: A list of permissions that the user possesses
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and prioritize issues from Rev organization REV-456 with priority p2 and then add them to sprint SPRINT-789[/INST]","var_1 = search_object_by_name(query=""REV-456"")
var_2 = works_list(issue.priority=[""p2""], issue.rev_orgs=[var_1], type=[""issue""])
var_3 = prioritize_objects(objects=var_2)
var_4 = add_work_items_to_sprint(work_ids=var_3, sprint_id=""SPRINT-789"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""

def fetch_user_tasks(user_id, include_completed=False):
""""""
Retrieves a list of tasks assigned to a user

Parameters:
    user_id (str): The ID of the user whose tasks are to be fetched
    include_completed (bool): Whether to include completed tasks in the list

Returns:
    list: List of tasks assigned to the user
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""


def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Determine my tasks in the 'development' stage and organize them by urgency[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""development""], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_data(report_type, data_set_id):
""""""
Generates report data based on the provided report type and data set

Parameters:
    report_type (str): The type of report to generate
    data_set_id (str): The ID of the data set to be used for the report

Returns:
    str: A report data string or ID depending on internal implementation
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def create_report_for_sprint(sprint_id, report_type):
""""""
Generates a report for a given sprint

Parameters:
    sprint_id (str): The ID of the sprint
    report_type (str): The type of report to be generated

Returns:
    str: The ID of the generated report
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Generate a summary of issues tagged with 'Urgent-Fix' and assign them to the 'Hotfix' sprint.[/INST]","var_1 = search_object_by_name(query=""Urgent-Fix"")
var_2 = works_list(issue.rev_orgs=[var_1], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_2, sprint_id=""Hotfix"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize all tickets from the SALES source channel and prioritize them, limiting the number of work items to 30.[/INST]","var_1 = works_list(ticket.source_channel=[""SALES""], type=[""ticket""], limit=30)
var_2 = prioritize_objects(objects=var_1)
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_tasks_by_due_date(task_ids, due_date):
""""""
Filters tasks by their due date

Parameters:
    task_ids (list): A list of task IDs to filter
    due_date (str): The due date to filter tasks by

Returns:
    list: List of task IDs that have the specified due date
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_work_item_history(work_id):
""""""
Retrieves the history of changes for a given work item

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: A chronological list of changes made to the work item
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_project_timeline(project_id):
""""""
Retrieves the timeline and key milestones of a project

Parameters:
    project_id (str): The ID of the project for which the timeline is requested

Returns:
    list: Key milestones and dates for the project timeline
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add P0 and P1 priority issues from REV-TEAM-99 to the current sprint[/INST]","var_1 = search_object_by_name(query=""REV-TEAM-99"")
var_2 = works_list(issue.rev_orgs=[var_1], issue.priority=[""p0"", ""p1""], type=[""issue""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def filter_projects_by_status(project_ids, status=""active""):
""""""
Filters a list of project IDs by their status

Parameters:
    project_ids (list): A list of project IDs to filter
    status (str): The status to filter by, default is 'active'

Returns:
    list: Project IDs matching the status
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all tasks related to feature FEAT-XYZ, summarize their current status[/INST]","var_1 = works_list(type=[""task""], applies_to_part=[""FEAT-XYZ""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def schedule_meeting_with_user(user_id, duration=30, urgent=False):
""""""
Schedules a meeting with a specified user

Parameters:
    user_id (str): The ID of the user with whom to schedule a meeting
    duration (int): Duration of the meeting in minutes, default is '30'
    urgent (bool): Whether the meeting is urgent, defaults to False

Returns:
    str: The ID of the scheduled meeting
""""""


def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_system_event(event_type, description, user_id=None):
""""""
Logs an event in the system with an optional user ID associated with it

Parameters:
    event_type (str): The type of event to log
    description (str): A brief description of the event
    user_id (str): The ID of the user involved in the event, if applicable

Returns:
    str: The ID of the logged event
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_completed_tasks_by_user(user_id):
""""""
Lists all completed tasks for a specific user

Parameters:
    user_id (str): The ID of the user whose completed tasks need to be listed

Returns:
    list: List of completed task IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def set_user_permission(user_id, permission_level):
""""""
Sets a specific permission level for a user account

Parameters:
    user_id (str): The ID of the user to set permissions for
    permission_level (str): The level of permission to assign e.g., 'read', 'write', 'admin'

Returns:
    bool: True if the permission was set successfully, False otherwise
""""""


def calculate_budget_allocation(project_id, cost_limit):
""""""
Calculates and assigns the budget allocation for a project

Parameters:
    project_id (str): The ID of the project for which the budget is calculated
    cost_limit (float): The cost limit for the project's budget

Returns:
    float: The amount allocated to the project budget
""""""


def check_inventory_availability(part_id, minimum_quantity=1):
""""""
Checks if the inventory has the specified part in at least the minimum quantity

Parameters:
    part_id (str): The ID of the part to check in inventory
    minimum_quantity (int): The minimum quantity to check for; defaults to 1

Returns:
    bool: True if the minimum quantity is available; otherwise False
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add all P2 issues from customer BigCorp to the sprint and list them[/INST]","var_1 = search_object_by_name(query=""BigCorp"")
var_2 = works_list(issue.rev_orgs=[var_1], issue.priority=[""p2""], type=[""issue""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Is there a purpose to suffering, or is it an inherent aspect of the human experience?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_department_members(department_id):
""""""
Returns a list of user IDs for all members within a specified department

Parameters:
    department_id (str): The ID of the department to list members for

Returns:
    list: User IDs of all the members in the department
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""


def estimate_task_duration(task_id, complexity_level):
""""""
Estimates the duration needed to complete a task based on its complexity level

Parameters:
    task_id (str): The ID of the task
    complexity_level (str): The complexity level of the task. Allowed values: 'low', 'medium', 'high'

Returns:
    float: Estimated duration in hours
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def reassign_work_item_owner(work_id, new_owner_id):
""""""
Reassigns the owner of a work item to a new user

Parameters:
    work_id (str): The ID of the work item to be reassigned
    new_owner_id (str): The user ID of the new owner

Returns:
    bool: True if reassignment is successful, False otherwise
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize work items for parts FEAT-999 and ENH-999 created by user DEVU-999[/INST]","var_1 = works_list(applies_to_part=[""FEAT-999"", ""ENH-999""], created_by=[""DEVU-999""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_system_event(event_type, description, user_id=None):
""""""
Logs an event in the system with an optional user ID associated with it

Parameters:
    event_type (str): The type of event to log
    description (str): A brief description of the event
    user_id (str): The ID of the user involved in the event, if applicable

Returns:
    str: The ID of the logged event
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_task_dependencies(task_id):
""""""
Returns a list of task IDs that are dependencies for the given task

Parameters:
    task_id (str): The ID of the task for which dependencies are requested

Returns:
    list: Dependency task IDs
""""""


def filter_users_by_skill(skill_name, minimum_proficiency=3):
""""""
Filters users by a specific skill and its minimum proficiency level

Parameters:
    skill_name (str): The name of the skill to filter by
    minimum_proficiency (int): The minimum proficiency level a user should have in the skill

Returns:
    list: A list of user IDs that match the criteria
""""""


def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize tasks related to project ALPHA, then add urgent tasks to the sprint.[/INST]","var_1 = search_object_by_name(query=""ALPHA"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = summarize_objects(objects=var_2)
var_4 = prioritize_objects(objects=var_2)
var_5 = get_sprint_id()
var_6 = add_work_items_to_sprint(work_ids=var_4, sprint_id=var_5)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def validate_project_completion(project_id):
""""""
Validates if all tasks within a project are completed

Parameters:
    project_id (str): The ID of the project to validate

Returns:
    bool: True if completed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def update_object_status(object_id, new_status, changed_by):
""""""
Updates the status of an object and records the user that made the change

Parameters:
    object_id (str): The ID of the object for which the status is updated
    new_status (str): The new status for the object
    changed_by (str): The ID of the user who is changing the status

Returns:
    None
""""""


def filter_contacts_by_organization(organization_id, active_only=True):
""""""
Returns a list of contacts associated with the specified organization, optionally filtering only active contacts

Parameters:
    organization_id (str): The ID of the organization to filter contacts
    active_only (bool): Flag to filter only active contacts, default value 'True'

Returns:
    list: Contacts associated with the organization
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def calculate_progress_percentage(project_id):
""""""
Calculates the progress percentage of the given project

Parameters:
    project_id (str): The ID of the project for which to calculate progress

Returns:
    float: The percentage of project completion
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def log_system_activity(activity_description, user_id=None):
""""""
Logs a system activity with an optional user ID

Parameters:
    activity_description (str): A brief description of the activity being logged
    user_id (str, optional): The ID of the user associated with the activity; defaults to None

Returns:
    bool: True if the activity was logged successfully; otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""

def fetch_user_tasks(user_id, include_completed=False):
""""""
Retrieves a list of tasks assigned to a user

Parameters:
    user_id (str): The ID of the user whose tasks are to be fetched
    include_completed (bool): Whether to include completed tasks in the list

Returns:
    list: List of tasks assigned to the user
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Fetch and prioritize tasks for user USER-789 in 'development' stage[/INST]","var_1 = works_list(owned_by=[""USER-789""], stage.name=[""development""], type=[""task""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_work_items(primary_work_id, duplicate_work_ids):
""""""
Merges duplicate work items into the primary work item

Parameters:
    primary_work_id (str): The ID of the primary work item
    duplicate_work_ids (list): List of IDs of duplicate work items to be merged

Returns:
    bool: True if merge was successful, otherwise False
""""""


def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""


def fetch_user_created_work(user_id, work_type=None):
""""""
Retrieves work items created by a specific user

Parameters:
    user_id (str): The ID of the user whose work items are to be retrieved
    work_type (list): Filters for work of the provided types, e.g., ['issue', 'ticket']

Returns:
    list: Work items created by the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def find_user_by_email(email):
""""""
Finds a user in the system by their email address

Parameters:
    email (str): The email address of the user to find

Returns:
    str: ID of the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What if the purpose of life is not to find meaning but to create it, shaping our own existential narrative?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""


def generate_report_data(report_type, data_set_id):
""""""
Generates report data based on the provided report type and data set

Parameters:
    report_type (str): The type of report to generate
    data_set_id (str): The ID of the data set to be used for the report

Returns:
    str: A report data string or ID depending on internal implementation
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""


def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def assign_tickets_to_user(ticket_ids, user_id):
""""""
Assigns a set of tickets to a specified user

Parameters:
    ticket_ids (list): A list of ticket IDs to be assigned
    user_id (str): The ID of the user to whom the tickets will be assigned

Returns:
    None
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create actionable tasks from the team meeting notes M and prioritize them for the current sprint[/INST]","var_1 = create_actionable_tasks_from_text(text=""M"")
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_due_date(work_item_id, due_date):
""""""
Updates the due date for the specified work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    due_date (str): The new due date for the work item

Returns:
    None: Indicates that the operation was executed without returning any value
""""""


def merge_duplicate_work_items(primary_work_id, duplicate_work_ids):
""""""
Merges duplicate work items into the primary work item

Parameters:
    primary_work_id (str): The ID of the primary work item
    duplicate_work_ids (list): List of IDs of duplicate work items to be merged

Returns:
    bool: True if merge was successful, otherwise False
""""""


def validate_project_completion(project_id):
""""""
Validates if all tasks within a project are completed

Parameters:
    project_id (str): The ID of the project to validate

Returns:
    bool: True if completed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def remove_work_item_from_sprint(work_id, sprint_id):
""""""
Removes the specified work item from a sprint

Parameters:
    work_id (str): The ID of the work item to be removed
    sprint_id (str): The ID of the sprint from which to remove the work item

Returns:
    bool: True if the removal was successful, False otherwise
""""""


def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def archive_old_tickets(older_than_date, active_status=False):
""""""
Archives tickets that are older than the specified date, optionally filters by active status and returns the IDs

Parameters:
    older_than_date (str): A date in the format 'YYYY-MM-DD', to filter tickets older than this date
    active_status (bool): If True, only archives tickets that are currently active; defaults to False

Returns:
    str: ID of tickets archived
""""""


def validate_data_consistency(data_id, schema_id):
""""""
Validates if data conforms to a specified schema for consistency

Parameters:
    data_id (str): The ID of the data to be validated
    schema_id (str): The ID of the schema to validate the data against

Returns:
    bool: True if data is consistent, False otherwise
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and summarize all open tickets for the current sprint[/INST]","var_1 = get_sprint_id()
var_2 = works_list(stage.name=[var_1], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""


def find_user_by_email(email):
""""""
Finds a user in the system by their email address

Parameters:
    email (str): The email address of the user to find

Returns:
    str: ID of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_estimated_completion(project_id):
""""""
Calculates the estimated completion date for a project based on current progress

Parameters:
    project_id (str): The ID of the project to be analyzed

Returns:
    str: Estimated date of completion
""""""


def link_related_documents(doc_id, related_doc_ids):
""""""
Links related documents to the given document in the system

Parameters:
    doc_id (str): The ID of the document to which related documents should be linked
    related_doc_ids (list): A list of IDs for related documents

Returns:
    bool: True if the operation was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve the current sprint ID, list all tasks due this week, and add them to the sprint.[/INST]","var_1 = get_sprint_id()
var_2 = works_list(type=[""task""], stage.name=[""due this week""])
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""


def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""


def get_user_contact_info(user_id):
""""""
Retrieves contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact information is requested

Returns:
    str: The contact information of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_system_event(event_type, description, user_id=None):
""""""
Logs an event in the system with an optional user ID associated with it

Parameters:
    event_type (str): The type of event to log
    description (str): A brief description of the event
    user_id (str): The ID of the user involved in the event, if applicable

Returns:
    str: The ID of the logged event
""""""


def list_completed_tasks_by_user(user_id, project_id=None):
""""""
Lists all tasks completed by a given user, optionally filtered by project

Parameters:
    user_id (str): The ID of the user
    project_id (str, optional): The ID of the project to filter tasks

Returns:
    list: List of task IDs completed by the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def list_completed_items_by_user(user_id):
""""""
Lists items that have been completed by the given user

Parameters:
    user_id (str): The ID of the user whose completed items are being requested

Returns:
    list: Completed items by the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        How do I apply for a job at Google?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def fetch_users_from_group(group_id):
""""""
Retrieves a list of user IDs that belong to the specified group

Parameters:
    group_id (str): The ID of the group

Returns:
    list: User IDs belonging to the group
""""""


def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""


def remove_object_from_inventory(object_id):
""""""
Removes an object from the inventory system based on the object ID

Parameters:
    object_id (str): The ID of the object to remove from inventory

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def mark_ticket_for_review(ticket_id, reviewer_id):
""""""
Marks a ticket for review by a specific user

Parameters:
    ticket_id (str): The ID of the ticket to be marked for review
    reviewer_id (str): The ID of the user who should review the ticket

Returns:
    None
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def set_user_permission(user_id, permission_level):
""""""
Sets a specific permission level for a user account

Parameters:
    user_id (str): The ID of the user to set permissions for
    permission_level (str): The level of permission to assign e.g., 'read', 'write', 'admin'

Returns:
    bool: True if the permission was set successfully, False otherwise
""""""


def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Is reality a fixed construct, or does it adapt and evolve based on our collective consciousness?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def archive_old_tickets(older_than_date, active_status=False):
""""""
Archives tickets that are older than the specified date, optionally filters by active status and returns the IDs

Parameters:
    older_than_date (str): A date in the format 'YYYY-MM-DD', to filter tickets older than this date
    active_status (bool): If True, only archives tickets that are currently active; defaults to False

Returns:
    str: ID of tickets archived
""""""


def deactivate_user_account(user_id, reason):
""""""
Deactivates a user account for a specific reason

Parameters:
    user_id (str): The ID of the user whose account is to be deactivated
    reason (str): The reason for deactivating the account

Returns:
    bool: True if the account was successfully deactivated; otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items related to 'FeatureX' and add them to sprint 'Sprint-22'[/INST]","var_1 = search_object_by_name(query=""FeatureX"")
var_2 = works_list(applies_to_part=[var_1], type=[""issue"", ""ticket"", ""task""])
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=""Sprint-22"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""


def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_time_until_deadline(work_item_id):
""""""
Calculates the amount of time remaining until the deadline of a work item

Parameters:
    work_item_id (str): The ID of the work item

Returns:
    float: The number of hours until the deadline
""""""

def assign_issues_to_user(issue_ids, user_id):
""""""
Assigns a list of issues to the specified user

Parameters:
    issue_ids (list): A list of issue IDs that need to be assigned
    user_id (str): The user ID to whom the issues will be assigned

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def generate_report_by_tag(tag_id, include_archived=False):
""""""
Generates a report for all work items associated with the given tag

Parameters:
    tag_id (str): The ID of the tag used to filter work items
    include_archived (bool): Include archived work items if set to True

Returns:
    list: Work items associated with the tag
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def list_all_blocked_tickets():
""""""
Lists all tickets that are currently blocked

Returns:
    list: Ticket IDs that are currently blocked
""""""


def merge_duplicate_records(primary_record_id, duplicate_record_id):
""""""
Merges a duplicate record into a primary record

Parameters:
    primary_record_id (str): The ID of the primary record to keep
    duplicate_record_id (str): The ID of the duplicate record to merge

Returns:
    bool: True if the merge was successful; otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Generate a list of tickets from the Engineering department, prioritize them by severity, and add themto the upcoming sprint[/INST]","var_1 = works_list(issue.rev_orgs=[""Engineering""], type=[""ticket""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def generate_report_by_tag(tag_id, include_archived=False):
""""""
Generates a report for all work items associated with the given tag

Parameters:
    tag_id (str): The ID of the tag used to filter work items
    include_archived (bool): Include archived work items if set to True

Returns:
    list: Work items associated with the tag
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify my tasks that are in 'development' stage, filter for high priority, and add them to sprint SPRINT-101[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""development""], issue.priority=[""high""], type=[""task""])
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=""SPRINT-101"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_due_date(work_item_id, due_date):
""""""
Updates the due date for the specified work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    due_date (str): The new due date for the work item

Returns:
    None: Indicates that the operation was executed without returning any value
""""""


def retrieve_user_workload(user_id):
""""""
Retrieves the current workload for the specified user

Parameters:
    user_id (str): The ID of the user whose workload is to be retrieved

Returns:
    list: A list containing workload details
""""""


def calculate_budget_remaining(budget_id):
""""""
Calculates the remaining budget for a given budget ID

Parameters:
    budget_id (str): The ID of the budget to calculate

Returns:
    float: The amount of remaining budget
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def list_completed_items_by_user(user_id):
""""""
Lists items that have been completed by the given user

Parameters:
    user_id (str): The ID of the user whose completed items are being requested

Returns:
    list: Completed items by the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""


def batch_update_user_roles(user_ids, new_role):
""""""
Updates the roles for a batch of users to a new role

Parameters:
    user_ids (list): List of user IDs whose roles should be updated
    new_role (str): The new role to assign

Returns:
    int: Number of users successfully updated
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_completed_tasks_by_user(user_id):
""""""
Lists all completed tasks for a specific user

Parameters:
    user_id (str): The ID of the user whose completed tasks need to be listed

Returns:
    list: List of completed task IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a given date range.

Parameters:
    start_date (str): The start date of the desired date range
    end_date (str): The end date of the desired date range
    work_type (list): Optional filter for type of work

Returns:
    list: Work items within the specified date range
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize tasks for the 'NextGen' project and prioritize for the sprint[/INST]","var_1 = search_object_by_name(query=""NextGen"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = summarize_objects(objects=var_2)
var_4 = prioritize_objects(objects=var_2)
var_5 = get_sprint_id()
var_6 = add_work_items_to_sprint(work_ids=var_4, sprint_id=var_5)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""


def merge_duplicate_work_items(primary_work_id, duplicate_work_ids):
""""""
Merges duplicate work items into the primary work item

Parameters:
    primary_work_id (str): The ID of the primary work item
    duplicate_work_ids (list): List of IDs of duplicate work items to be merged

Returns:
    bool: True if merge was successful, otherwise False
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What if our thoughts have a tangible impact on the physical world?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all tasks related to project AlphaGo and categorize them by priority[/INST]","var_1 = search_object_by_name(query=""AlphaGo"")
var_2 = works_list(type=[""task""], applies_to_part=[var_1])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def assign_issues_to_user(issue_ids, user_id):
""""""
Assigns a list of issues to the specified user

Parameters:
    issue_ids (list): A list of issue IDs that need to be assigned
    user_id (str): The user ID to whom the issues will be assigned

Returns:
    None
""""""


def remove_users_from_group(user_ids, group_id):
""""""
Removes the specified users from a group

Parameters:
    user_ids (list): A list of user IDs to be removed from the group
    group_id (str): The ID of the group from which the users should be removed

Returns:
    bool: Status of the removal
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def merge_duplicate_records(primary_record_id, duplicate_record_id):
""""""
Merges a duplicate record into a primary record

Parameters:
    primary_record_id (str): The ID of the primary record to keep
    duplicate_record_id (str): The ID of the duplicate record to merge

Returns:
    bool: True if the merge was successful; otherwise False
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def calculate_estimate_completion_time(work_id):
""""""
Calculates the estimated completion time for the specified work item

Parameters:
    work_id (str): The ID of the work item to calculate the estimated time

Returns:
    float: Estimated completion time in hours
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For my tickets marked as 'blocker', create a prioritized list and add it to the current sprint.[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], ticket.severity=[""blocker""], type=[""ticket""])
var_3 = prioritize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify tickets that need a response for ""Gamma Initiative"" and create a summary[/INST]","var_1 = search_object_by_name(query=""Gamma Initiative"")
var_2 = works_list(ticket.needs_response=True, ticket.rev_org=[var_1], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_sprint_history(sprint_id):
""""""
Retrieves the change history of a sprint

Parameters:
    sprint_id (str): The ID of the ticket

Returns:
    list: A list of changes made to the sprint
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def get_recent_activity_log(user_id, limit=10):
""""""
Gets the most recent activity log entries for a given user

Parameters:
    user_id (str): The ID of the user to get activities for
    limit (int): The maximum number of activity log entries to return

Returns:
    list: Recent activity log entries
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def extract_contact_info(text_id, entity_type):
""""""
Extracts contact information from a text source based on a given entity type

Parameters:
    text_id (str): The ID of the text source from which to extract contact information
    entity_type (str): The type of entity to extract info from. Allowed values: 'individual', 'company'

Returns:
    list: Extracted contact information
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def filter_records_by_date(record_ids, start_date, end_date):
""""""
Filters a list of record IDs based on a date range

Parameters:
    record_ids (list): List of record IDs to filter
    start_date (str): Start date for the filtering in 'YYYY-MM-DD' format
    end_date (str): End date for the filtering in 'YYYY-MM-DD' format

Returns:
    list: Filtered record IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items related to ""ENH-456"", prioritize them, and add to the current sprint.[/INST]","var_1 = search_object_by_name(query=""ENH-456"")
var_2 = get_similar_work_items(work_id=var_1)
var_3 = prioritize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_data(report_type, data_set_id):
""""""
Generates report data based on the provided report type and data set

Parameters:
    report_type (str): The type of report to generate
    data_set_id (str): The ID of the data set to be used for the report

Returns:
    str: A report data string or ID depending on internal implementation
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def list_user_tasks(user_id, completed=False):
""""""
Lists all tasks assigned to a user, optionally filtering for completed tasks

Parameters:
    user_id (str): The ID of the user whose tasks are to be listed
    completed (bool): If True, only completed tasks are returned

Returns:
    list: A list of tasks assigned to the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""

def fetch_user_tasks(user_id, include_completed=False):
""""""
Retrieves a list of tasks assigned to a user

Parameters:
    user_id (str): The ID of the user whose tasks are to be fetched
    include_completed (bool): Whether to include completed tasks in the list

Returns:
    list: List of tasks assigned to the user
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def filter_users_by_skill(skill_name, minimum_proficiency=3):
""""""
Filters users by a specific skill and its minimum proficiency level

Parameters:
    skill_name (str): The name of the skill to filter by
    minimum_proficiency (int): The minimum proficiency level a user should have in the skill

Returns:
    list: A list of user IDs that match the criteria
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What are the best practices for organic gardening?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def remove_object_by_id(object_id):
""""""
Removes an object from the system by its ID

Parameters:
    object_id (str): The ID of the object to remove

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""


def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def merge_duplicate_records(primary_record_id, duplicate_record_id):
""""""
Merges a duplicate record into a primary record

Parameters:
    primary_record_id (str): The ID of the primary record to keep
    duplicate_record_id (str): The ID of the duplicate record to merge

Returns:
    bool: True if the merge was successful; otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def retrieve_sprint_workload(sprint_id):
""""""
Calculates the total workload for a given sprint based on the work items associated with it

Parameters:
    sprint_id (str): The ID of the sprint for workload calculation

Returns:
    float: Total workload in hours
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize and prioritize tasks assigned to 'DEVU-789' that are in the 'development' stage.[/INST]","var_1 = search_object_by_name(query=""DEVU-789"")
var_2 = works_list(owned_by=[var_1], stage.name=[""development""], type=[""task""])
var_3 = summarize_objects(objects=var_2)
var_4 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def calculate_estimate_completion_time(work_id):
""""""
Calculates the estimated completion time for the specified work item

Parameters:
    work_id (str): The ID of the work item to calculate the estimated time

Returns:
    float: Estimated completion time in hours
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify work items related to ""Feature-999"", summarize them, and add them to the current sprint[/INST]","var_1 = search_object_by_name(query=""Feature-999"")
var_2 = works_list(applies_to_part=[var_1], type=[""issue"", ""ticket"", ""task""])
var_3 = summarize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_ticket_comments(ticket_id):
""""""
Retrieves the comments attached to a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose comments are being retrieved

Returns:
    list: Comments associated with the ticket
""""""


def calculate_expense_totals(expense_ids):
""""""
Calculates the total amount from a list of expense IDs

Parameters:
    expense_ids (list): List of expense IDs to calculate the total amount

Returns:
    float: The total amount of the expenses
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""


def remove_work_item_from_sprint(work_id, sprint_id):
""""""
Removes the specified work item from a sprint

Parameters:
    work_id (str): The ID of the work item to be removed
    sprint_id (str): The ID of the sprint from which to remove the work item

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_estimated_effort(work_id):
""""""
Calculates the estimated effort required to complete a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    float: Estimated effort in hours
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify and summarize work items similar to ID ISSUE-999[/INST]","var_1 = get_similar_work_items(work_id=""ISSUE-999"")
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def assign_tasks_to_employee(task_ids, employee_id):
""""""
Assigns a list of tasks to the specified employee

Parameters:
    task_ids (list): A list of task IDs to be assigned
    employee_id (str): The ID of the employee to whom the tasks will be assigned

Returns:
    bool: True if the assignment was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def extract_contact_info(text_id, entity_type):
""""""
Extracts contact information from a text source based on a given entity type

Parameters:
    text_id (str): The ID of the text source from which to extract contact information
    entity_type (str): The type of entity to extract info from. Allowed values: 'individual', 'company'

Returns:
    list: Extracted contact information
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def check_inventory_availability(part_id, minimum_quantity=1):
""""""
Checks if the inventory has the specified part in at least the minimum quantity

Parameters:
    part_id (str): The ID of the part to check in inventory
    minimum_quantity (int): The minimum quantity to check for; defaults to 1

Returns:
    bool: True if the minimum quantity is available; otherwise False
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items of type 'issue'  and add those to the current sprint which belong to CAPL-789[/INST]","var_1 = works_list(applies_to_part=[""CAPL-789""], type=[""issue""])
var_2 = get_sprint_id()
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_recent_activities(user_id, limit=10):
""""""
Lists the most recent activities performed by a user

Parameters:
    user_id (str): The ID of the user whose activities are to be listed
    limit (int): The maximum number of recent activities to return

Returns:
    list: Recent activities of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def merge_duplicate_objects(primary_object_id, duplicate_object_id):
""""""
Merges a duplicate object into a primary object

Parameters:
    primary_object_id (str): The ID of the primary object
    duplicate_object_id (str): The ID of the duplicate object to be merged

Returns:
    bool: True if the merge was successful, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a given date range.

Parameters:
    start_date (str): The start date of the desired date range
    end_date (str): The end date of the desired date range
    work_type (list): Optional filter for type of work

Returns:
    list: Work items within the specified date range
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Look through all my issues and add any P1 issues to the current sprint[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], issue.priority=[""p1""], type=[""issue""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_contact_info(user_id):
""""""
Retrieves the contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact info is requested

Returns:
    str: Contact information of the user
""""""


def find_work_items_by_tag(work_type, tag):
""""""
Finds work items of a certain type with a given tag

Parameters:
    work_type (str): The type of the work items to filter by
    tag (str): The tag to filter the work items

Returns:
    list: List of work items with the given tag
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def update_object_status(object_id, new_status, changed_by):
""""""
Updates the status of an object and records the user that made the change

Parameters:
    object_id (str): The ID of the object for which the status is updated
    new_status (str): The new status for the object
    changed_by (str): The ID of the user who is changing the status

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def archive_old_tickets(older_than_date, active_status=False):
""""""
Archives tickets that are older than the specified date, optionally filters by active status and returns the IDs

Parameters:
    older_than_date (str): A date in the format 'YYYY-MM-DD', to filter tickets older than this date
    active_status (bool): If True, only archives tickets that are currently active; defaults to False

Returns:
    str: ID of tickets archived
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def check_inventory_availability(part_id, minimum_quantity=1):
""""""
Checks if the inventory has the specified part in at least the minimum quantity

Parameters:
    part_id (str): The ID of the part to check in inventory
    minimum_quantity (int): The minimum quantity to check for; defaults to 1

Returns:
    bool: True if the minimum quantity is available; otherwise False
""""""


def generate_progress_report(project_id):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which to generate the report

Returns:
    str: A string summary of the project's progress report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize all high severity tickets created by CustomerSuccessTeam and limit the number of work items to 24.[/INST]","var_1 = works_list(created_by=[""CustomerSuccessTeam""], ticket.severity=[""high""], type=[""ticket""], limit=24)
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_recent_projects(user_id, days_back=30):
""""""
Lists all projects a user has worked on in the past number of days

Parameters:
    user_id (str): The ID of the user
    days_back (int): The number of past days to look for projects. The default is '30'

Returns:
    list: Project IDs that the user has worked on
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def list_recent_activities(user_id, limit=10):
""""""
Lists the most recent activities performed by a user

Parameters:
    user_id (str): The ID of the user whose activities are to be listed
    limit (int): The maximum number of recent activities to return

Returns:
    list: Recent activities of the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def list_all_blocked_tickets():
""""""
Lists all tickets that are currently blocked

Returns:
    list: Ticket IDs that are currently blocked
""""""


def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize all tasks in 'QA Testing' stage for part 'TEST-987'.[/INST]","var_1 = search_object_by_name(query=""TEST-987"")
var_2 = works_list(applies_to_part=[var_1], stage.name=[""QA Testing""], type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def mark_ticket_for_review(ticket_id, reviewer_id):
""""""
Marks a ticket for review by a specific user

Parameters:
    ticket_id (str): The ID of the ticket to be marked for review
    reviewer_id (str): The ID of the user who should review the ticket

Returns:
    None
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items for part CAPL-123, filter by Rev organization REV-ORG-456, and summarize the results[/INST]","var_1 = search_object_by_name(query=""REV-ORG-456"")
var_2 = works_list(applies_to_part=[""CAPL-123""], issue.rev_orgs=[var_1], type=[""issue"", ""ticket"", ""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def filter_users_by_department(department_id=None, active_only=False):
""""""
Filters a list of users that belong to the specified department

Parameters:
    department_id (str): The ID of the department to filter users
    active_only (bool): Filters for only active users if set to True

Returns:
    list: Users in the specified department
""""""


def remove_work_item_from_sprint(work_id, sprint_id):
""""""
Removes the specified work item from a sprint

Parameters:
    work_id (str): The ID of the work item to be removed
    sprint_id (str): The ID of the sprint from which to remove the work item

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve my work of the type ""issue"" and ""task"", add them to the current sprint, and then get a summary of the sprint contents.[/INST]","var_1 = who_am_i()
var_2 = works_list(created_by=[var_1], type=[""issue"", ""task""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
var_5 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def list_completed_tasks_by_user(user_id, project_id=None):
""""""
Lists all tasks completed by a given user, optionally filtered by project

Parameters:
    user_id (str): The ID of the user
    project_id (str, optional): The ID of the project to filter tasks

Returns:
    list: List of task IDs completed by the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def set_user_permission(user_id, permission_level):
""""""
Sets a specific permission level for a user account

Parameters:
    user_id (str): The ID of the user to set permissions for
    permission_level (str): The level of permission to assign e.g., 'read', 'write', 'admin'

Returns:
    bool: True if the permission was set successfully, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize and summarize my tasks related to the Rev organization REV-678[/INST]","var_1 = who_am_i()
var_2 = works_list(type=[""task""], owned_by=[var_1], issue.rev_orgs=[""REV-678""])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_recent_projects(user_id, days_back=30):
""""""
Lists all projects a user has worked on in the past number of days

Parameters:
    user_id (str): The ID of the user
    days_back (int): The number of past days to look for projects. The default is '30'

Returns:
    list: Project IDs that the user has worked on
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create a summary of tickets needing response from the support team[/INST]","var_1 = works_list(ticket.needs_response=True, type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_progress_percentage(project_id):
""""""
Calculates the progress percentage of the given project

Parameters:
    project_id (str): The ID of the project for which to calculate progress

Returns:
    float: The percentage of project completion
""""""


def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_project_summary(project_id):
""""""
Generates a summary report for the specified project

Parameters:
    project_id (str): The ID of the project to summarize

Returns:
    str: A summary report of the project
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_status(work_item_id, status_options):
""""""
Checks if the given work item has a status that is among the provided options

Parameters:
    work_item_id (str): The ID of the work item to check
    status_options (list): A list of valid status options

Returns:
    bool: True if status is valid, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create tasks from meeting notes ""M"" and get the current sprint ID[/INST]","var_1 = create_actionable_tasks_from_text(text=""M"")
var_2 = get_sprint_id()
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""


def convert_task_to_subtask(task_id, parent_task_id):
""""""
Converts a standalone task into a subtask of another task

Parameters:
    task_id (str): The ID of the task to be converted
    parent_task_id (str): The ID of the parent task to which the subtask will be linked

Returns:
    bool: True if the conversion was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_budget_allocation(project_id, cost_limit):
""""""
Calculates and assigns the budget allocation for a project

Parameters:
    project_id (str): The ID of the project for which the budget is calculated
    cost_limit (float): The cost limit for the project's budget

Returns:
    float: The amount allocated to the project budget
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_team_member_list(team_id):
""""""
Retrieves a list of team members for the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: List of team member IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and summarize my tasks, then prioritize them before the current team meeting[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], type=[""task""])
var_3 = summarize_objects(objects=var_2)
var_4 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def estimate_ticket_resolution_time(ticket_id):
""""""
Estimates the resolution time for a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to estimate time for

Returns:
    float: Estimated time in hours to resolve the ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def generate_report_by_tag(tag_id, include_archived=False):
""""""
Generates a report for all work items associated with the given tag

Parameters:
    tag_id (str): The ID of the tag used to filter work items
    include_archived (bool): Include archived work items if set to True

Returns:
    list: Work items associated with the tag
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def validate_data_consistency(data_id, schema_id):
""""""
Validates if data conforms to a specified schema for consistency

Parameters:
    data_id (str): The ID of the data to be validated
    schema_id (str): The ID of the schema to validate the data against

Returns:
    bool: True if data is consistent, False otherwise
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify and summarize all tasks that need a response for the REV-321 project[/INST]","var_1 = search_object_by_name(query=""REV-321"")
var_2 = works_list(ticket.rev_org=[var_1], ticket.needs_response=True, type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and summarize issues owned by ProductManagerX and limit the results to 35.[/INST]","var_1 = works_list(owned_by=[""ProductManagerX""], type=[""issue""], limit=35)
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def remove_object_from_archive(object_id):
""""""
Removes an object from the system archive, making it active again

Parameters:
    object_id (str): The ID of the object to be removed from the archive

Returns:
    bool: True if the object was successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def list_all_blocked_tickets():
""""""
Lists all tickets that are currently blocked

Returns:
    list: Ticket IDs that are currently blocked
""""""


def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_user_skills(user_id):
""""""
Lists the skills associated with the specified user

Parameters:
    user_id (str): The ID of the user whose skills are being queried

Returns:
    list: The skills of the user
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""


def merge_duplicate_tickets(primary_ticket_id, duplicate_ticket_ids):
""""""
Merges duplicate tickets into a primary ticket

Parameters:
    primary_ticket_id (str): The ID of the primary ticket that remains
    duplicate_ticket_ids (list): The IDs of the duplicate tickets to be merged into the primary

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find issues linked to project PROJ-456 with priority P1 and summarize them[/INST]","var_1 = search_object_by_name(query=""PROJ-456"")
var_2 = works_list(issue.rev_orgs=[var_1], issue.priority=[""p1""], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def generate_report_by_tag(tag_id, include_archived=False):
""""""
Generates a report for all work items associated with the given tag

Parameters:
    tag_id (str): The ID of the tag used to filter work items
    include_archived (bool): Include archived work items if set to True

Returns:
    list: Work items associated with the tag
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add my recently created high priority tickets to the current sprint[/INST]","var_1 = who_am_i()
var_2 = get_sprint_id()
var_3 = works_list(created_by=[var_1], issue.priority=[""high""], type=[""ticket""])
var_4 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve a list of tickets with 'blocker' severity from REV-456 and summarize them for review[/INST]","var_1 = search_object_by_name(query=""REV-456"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add all P2 issues created by user User123 to the sprint[/INST]","var_1 = works_list(created_by=[""User123""], issue.priority=[""p2""], type=[""issue""])
var_2 = get_sprint_id()
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_expense_totals(expense_ids):
""""""
Calculates the total amount from a list of expense IDs

Parameters:
    expense_ids (list): List of expense IDs to calculate the total amount

Returns:
    float: The total amount of the expenses
""""""


def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def retrieve_document_by_keyword(keyword):
""""""
Retrieves a document ID containing the specified keyword

Parameters:
    keyword (str): The keyword to search for in the documents

Returns:
    str: ID of the document containing the keyword
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""


def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add all 'blocker' severity tickets created by user ""DEVU-456"" to the current sprint[/INST]","var_1 = search_object_by_name(query=""DEVU-456"")
var_2 = works_list(created_by=[var_1], ticket.severity=[""blocker""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def fetch_user_created_work(user_id, work_type=None):
""""""
Retrieves work items created by a specific user

Parameters:
    user_id (str): The ID of the user whose work items are to be retrieved
    work_type (list): Filters for work of the provided types, e.g., ['issue', 'ticket']

Returns:
    list: Work items created by the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def validate_user_permissions(user_id, required_permissions):
""""""
Checks if the user has the specified permissions

Parameters:
    user_id (str): The ID of the user whose permissions need to be checked
    required_permissions (list): A list of permissions to check against the user's permissions

Returns:
    bool: True if the user has all the required permissions, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""


def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize all tasks in the 'QA' stage for the 'MobileApp' project[/INST]","var_1 = search_object_by_name(query=""MobileApp"")
var_2 = works_list(stage.name=[""QA""], applies_to_part=[var_1], type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def fetch_users_from_group(group_id):
""""""
Retrieves a list of user IDs that belong to the specified group

Parameters:
    group_id (str): The ID of the group

Returns:
    list: User IDs belonging to the group
""""""


def calculate_expense_totals(expense_ids):
""""""
Calculates the total amount from a list of expense IDs

Parameters:
    expense_ids (list): List of expense IDs to calculate the total amount

Returns:
    float: The total amount of the expenses
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def list_completed_tasks_by_user(user_id, project_id=None):
""""""
Lists all tasks completed by a given user, optionally filtered by project

Parameters:
    user_id (str): The ID of the user
    project_id (str, optional): The ID of the project to filter tasks

Returns:
    list: List of task IDs completed by the user
""""""


def calculate_time_until_deadline(work_item_id):
""""""
Calculates the amount of time remaining until the deadline of a work item

Parameters:
    work_item_id (str): The ID of the work item

Returns:
    float: The number of hours until the deadline
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def assign_tasks_to_user(task_ids, user_id):
""""""
Assigns a list of task IDs to the provided user

Parameters:
    task_ids (list): List of task IDs to be assigned
    user_id (str): The ID of the user to whom the tasks will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def mark_ticket_for_review(ticket_id, reviewer_id):
""""""
Marks a ticket for review by a specific user

Parameters:
    ticket_id (str): The ID of the ticket to be marked for review
    reviewer_id (str): The ID of the user who should review the ticket

Returns:
    None
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve all blocker issues for component 'COMP-321', summarize and categorize by type[/INST]","var_1 = search_object_by_name(query=""COMP-321"")
var_2 = works_list(type=[""issue""], applies_to_part=[var_1], ticket.severity=[""blocker""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_progress_report(project_id, report_format=""summary""):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which the progress report is needed
    report_format (str): The format of the report; 'summary' or 'detailed'. The default is 'summary'

Returns:
    str: The generated progress report
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""


def link_related_documents(doc_id, related_doc_ids):
""""""
Links related documents to the given document in the system

Parameters:
    doc_id (str): The ID of the document to which related documents should be linked
    related_doc_ids (list): A list of IDs for related documents

Returns:
    bool: True if the operation was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""


def filter_tickets_by_date(ticket_ids, start_date, end_date=None):
""""""
Filters a list of ticket IDs based on a date range

Parameters:
    ticket_ids (list): A list of ticket IDs to filter
    start_date (str): The start date for the range
    end_date (str, optional): The end date for the range, defaults to None

Returns:
    list: Filtered list of ticket IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize tasks related to ""PROJ-1122"" and generate a summary[/INST]","var_1 = search_object_by_name(query=""PROJ-1122"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def assign_tasks_to_employee(task_ids, employee_id):
""""""
Assigns a list of tasks to the specified employee

Parameters:
    task_ids (list): A list of task IDs to be assigned
    employee_id (str): The ID of the employee to whom the tasks will be assigned

Returns:
    bool: True if the assignment was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def retrieve_document_by_keyword(keyword):
""""""
Retrieves a document ID containing the specified keyword

Parameters:
    keyword (str): The keyword to search for in the documents

Returns:
    str: ID of the document containing the keyword
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add all P1 enhancement issues created by user DEVU-456 to the sprint[/INST]","var_1 = search_object_by_name(query=""DEVU-456"")
var_2 = works_list(created_by=[var_1], issue.priority=[""p1""], type=[""issue""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def assign_tasks_to_user(task_ids, user_id):
""""""
Assigns a list of task IDs to the provided user

Parameters:
    task_ids (list): List of task IDs to be assigned
    user_id (str): The ID of the user to whom the tasks will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""


def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Extract actionable items from the meeting notes 'MeetingXyz' and assign them[/INST]","var_1 = create_actionable_tasks_from_text(text=""MeetingXyz"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_recent_projects(user_id, days_back=30):
""""""
Lists all projects a user has worked on in the past number of days

Parameters:
    user_id (str): The ID of the user
    days_back (int): The number of past days to look for projects. The default is '30'

Returns:
    list: Project IDs that the user has worked on
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def retrieve_document_by_keyword(keyword):
""""""
Retrieves a document ID containing the specified keyword

Parameters:
    keyword (str): The keyword to search for in the documents

Returns:
    str: ID of the document containing the keyword
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve all tasks created by ManagerMike and add them to the current sprint, limiting the number of work items to 35.[/INST]","var_1 = works_list(created_by=[""ManagerMike""], limit=35, type=[""task""])
var_2 = get_sprint_id()
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""


def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create tasks from meeting notes and summarize the newly created tasks[/INST]","var_1 = create_actionable_tasks_from_text(text=""meeting notes"")
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""


def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""


def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""


def fetch_user_created_work(user_id, work_type=None):
""""""
Retrieves work items created by a specific user

Parameters:
    user_id (str): The ID of the user whose work items are to be retrieved
    work_type (list): Filters for work of the provided types, e.g., ['issue', 'ticket']

Returns:
    list: Work items created by the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_budget_allocation(project_id, cost_limit):
""""""
Calculates and assigns the budget allocation for a project

Parameters:
    project_id (str): The ID of the project for which the budget is calculated
    cost_limit (float): The cost limit for the project's budget

Returns:
    float: The amount allocated to the project budget
""""""


def filter_records_by_date(record_ids, start_date, end_date):
""""""
Filters a list of record IDs based on a date range

Parameters:
    record_ids (list): List of record IDs to filter
    start_date (str): Start date for the filtering in 'YYYY-MM-DD' format
    end_date (str): End date for the filtering in 'YYYY-MM-DD' format

Returns:
    list: Filtered record IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize and summarize issues related to 'ProjectY' for the current sprint planning.[/INST]","var_1 = search_object_by_name(query=""ProjectY"")
var_2 = works_list(type=[""issue""], applies_to_part=[var_1])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""


def validate_project_completion(project_id):
""""""
Validates if all tasks within a project are completed

Parameters:
    project_id (str): The ID of the project to validate

Returns:
    bool: True if completed, False otherwise
""""""


def track_time_on_task(task_id, hours_spent):
""""""
Tracks time spent on a task by logging the number of hours

Parameters:
    task_id (str): The ID of the task on which time is spent
    hours_spent (float): The number of hours spent on the task

Returns:
    bool: Status of the time tracking
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items related to ""ENH-123"" created by ""DEVU-456"" and summarize them[/INST]","var_1 = search_object_by_name(query=""DEVU-456"")
var_2 = works_list(created_by=[var_1], applies_to_part=[""ENH-123""], type=[""issue"", ""ticket"", ""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def find_user_by_email(email):
""""""
Finds a user in the system by their email address

Parameters:
    email (str): The email address of the user to find

Returns:
    str: ID of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve the ID of the sprint for this month and list all P2 tickets owned by me in that sprint.[/INST]","var_1 = get_sprint_id()
var_2 = who_am_i()
var_3 = works_list(issue.priority=[""p2""], owned_by=[var_2], stage.name=[var_1], type=[""ticket""])
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Get the current sprint ID[/INST]","var_1 = get_sprint_id()
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_estimated_completion(project_id):
""""""
Calculates the estimated completion date for a project based on current progress

Parameters:
    project_id (str): The ID of the project to be analyzed

Returns:
    str: Estimated date of completion
""""""


def calculate_project_completion_rate(project_id):
""""""
Calculates the completion rate of tasks for a given project

Parameters:
    project_id (str): The ID of the project to calculate the completion rate for

Returns:
    float: The completion rate as a percentage
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def link_related_tickets(ticket_id, related_ids):
""""""
Links tickets that are related to each other

Parameters:
    ticket_id (str): The ID of the ticket that will be linked with related tickets
    related_ids (list): List of IDs for tickets that are related to the original ticket

Returns:
    bool: True if the linking is successful, False otherwise
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def link_related_documents(doc_id, related_doc_ids):
""""""
Links related documents to the given document in the system

Parameters:
    doc_id (str): The ID of the document to which related documents should be linked
    related_doc_ids (list): A list of IDs for related documents

Returns:
    bool: True if the operation was successful, False otherwise
""""""


def validate_data_consistency(data_id, schema_id):
""""""
Validates if data conforms to a specified schema for consistency

Parameters:
    data_id (str): The ID of the data to be validated
    schema_id (str): The ID of the schema to validate the data against

Returns:
    bool: True if data is consistent, False otherwise
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_task_dependencies(task_id):
""""""
Returns a list of task IDs that are dependencies for the given task

Parameters:
    task_id (str): The ID of the task for which dependencies are requested

Returns:
    list: Dependency task IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def generate_progress_report(project_id):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which to generate the report

Returns:
    str: A string summary of the project's progress report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For the given text 'M', create tasks and immediately prioritize them for execution.[/INST]","var_1 = create_actionable_tasks_from_text(text=""M"")
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def convert_task_to_subtask(task_id, parent_task_id):
""""""
Converts a standalone task into a subtask of another task

Parameters:
    task_id (str): The ID of the task to be converted
    parent_task_id (str): The ID of the parent task to which the subtask will be linked

Returns:
    bool: True if the conversion was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_contacts_by_organization(organization_id, active_only=True):
""""""
Returns a list of contacts associated with the specified organization, optionally filtering only active contacts

Parameters:
    organization_id (str): The ID of the organization to filter contacts
    active_only (bool): Flag to filter only active contacts, default value 'True'

Returns:
    list: Contacts associated with the organization
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_team_member_list(team_id):
""""""
Retrieves a list of team members for the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: List of team member IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
         Locate tickets with high severity from the MARKETING rev organization, summarize them, and limit the number of work items to 15.[/INST]","var_1 = search_object_by_name(query=""MARKETING"")
var_2 = works_list(ticket.rev_org=[var_1], ticket.severity=[""high""], limit=15, type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def link_issues_to_project(issue_ids, project_id):
""""""
Links the given issues to the specified project

Parameters:
    issue_ids (list): A list of issue IDs to be linked to the project
    project_id (str): The ID of the project to which the issues should be linked

Returns:
    bool: Status of the linking action
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""


def list_user_tasks(user_id, completed=False):
""""""
Lists all tasks assigned to a user, optionally filtering for completed tasks

Parameters:
    user_id (str): The ID of the user whose tasks are to be listed
    completed (bool): If True, only completed tasks are returned

Returns:
    list: A list of tasks assigned to the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def get_user_workload(user_id):
""""""
Determines the current workload for a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be determined

Returns:
    int: The number of tasks assigned to the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_completed_tasks_by_user(user_id):
""""""
Lists all completed tasks for a specific user

Parameters:
    user_id (str): The ID of the user whose completed tasks need to be listed

Returns:
    list: List of completed task IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def fetch_ticket_history(ticket_id, history_limit=10):
""""""
Fetches the history of changes to a given ticket

Parameters:
    ticket_id (str): The ID of the ticket for which the history is requested
    history_limit (int): Maximum number of history entries to retrieve. The default is '10'

Returns:
    list: A list of history records for the ticket
""""""


def generate_work_report(work_ids):
""""""
Generates a report for the given work items.

Parameters:
    work_ids (list): A list of work item IDs for report generation

Returns:
    str: The ID of the generated report
""""""


def check_availability_of_part(part_id):
""""""
Checks if a specific part is available in inventory

Parameters:
    part_id (str): The ID of the part to check for availability

Returns:
    bool: True if the part is available, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Search for issues reported by customer CustomerID-6789 and summarize the critical ones.[/INST]","var_1 = search_object_by_name(query=""CustomerID-6789"")
var_2 = works_list(created_by=[var_1], ticket.severity=[""blocker""], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""


def extract_keywords_from_text(text):
""""""
Given a text, extracts and returns the main keywords

Parameters:
    text (str): The text from which keywords are to be extracted

Returns:
    list: A list of extracted keywords
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks related to the ""Backend-Optimization"" and prioritize them[/INST]","var_1 = who_am_i()
var_2 = search_object_by_name(query=""Backend-Optimization"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
var_5 = prioritize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def remove_object_from_archive(object_id):
""""""
Removes an object from the system archive, making it active again

Parameters:
    object_id (str): The ID of the object to be removed from the archive

Returns:
    bool: True if the object was successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def list_completed_tasks_by_user(user_id, project_id=None):
""""""
Lists all tasks completed by a given user, optionally filtered by project

Parameters:
    user_id (str): The ID of the user
    project_id (str, optional): The ID of the project to filter tasks

Returns:
    list: List of task IDs completed by the user
""""""


def calculate_effort_for_task(task_id):
""""""
Calculates the effort spent on a specific task by summing subtasks

Parameters:
    task_id (str): The ID of the task for which the effort needs to be calculated

Returns:
    float: Total effort spent on the task
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_user_permissions(user_id):
""""""
Lists all the permissions that a user has within the system

Parameters:
    user_id (str): The ID of the user for whom permissions are being listed

Returns:
    list: A list of permissions that the user possesses
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def check_availability_of_part(part_id):
""""""
Checks if a specific part is available in inventory

Parameters:
    part_id (str): The ID of the part to check for availability

Returns:
    bool: True if the part is available, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create a list of issues for part PROD-456 and sort by priority[/INST]","var_1 = works_list(applies_to_part=[""PROD-456""], type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_user_workload(user_id):
""""""
Calculates the workload of a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be calculated

Returns:
    float: The calculated workload value
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def create_report_for_sprint(sprint_id, report_type):
""""""
Generates a report for a given sprint

Parameters:
    sprint_id (str): The ID of the sprint
    report_type (str): The type of report to be generated

Returns:
    str: The ID of the generated report
""""""


def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve my P1 tickets, and provide a summary for them [/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], ticket.severity=[""p1""], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        My girlfriend cheated on me. What should I do?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_contact_info(user_id):
""""""
Retrieves the contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact info is requested

Returns:
    str: Contact information of the user
""""""


def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""


def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def create_report_for_sprint(sprint_id, report_type):
""""""
Generates a report for a given sprint

Parameters:
    sprint_id (str): The ID of the sprint
    report_type (str): The type of report to be generated

Returns:
    str: The ID of the generated report
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""


def generate_progress_report(project_id):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which to generate the report

Returns:
    str: A string summary of the project's progress report
""""""


def check_availability_of_part(part_id):
""""""
Checks if a specific part is available in inventory

Parameters:
    part_id (str): The ID of the part to check for availability

Returns:
    bool: True if the part is available, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Search for a user by name 'Jane Doe', get all their tasks, prioritize them, and get a summary.[/INST]","var_1 = search_object_by_name(query=""Jane Doe"")
var_2 = works_list(owned_by=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize all 'blocker' severity tickets[/INST]","var_1 = works_list(type=[""ticket""], ticket.severity=[""blocker""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def track_time_on_task(task_id, hours_spent):
""""""
Tracks time spent on a task by logging the number of hours

Parameters:
    task_id (str): The ID of the task on which time is spent
    hours_spent (float): The number of hours spent on the task

Returns:
    bool: Status of the time tracking
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def remove_object_from_inventory(object_id):
""""""
Removes an object from the inventory system based on the object ID

Parameters:
    object_id (str): The ID of the object to remove from inventory

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def get_recent_activity_log(user_id, limit=10):
""""""
Gets the most recent activity log entries for a given user

Parameters:
    user_id (str): The ID of the user to get activities for
    limit (int): The maximum number of activity log entries to return

Returns:
    list: Recent activity log entries
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_budget_allocation(project_id, cost_limit):
""""""
Calculates and assigns the budget allocation for a project

Parameters:
    project_id (str): The ID of the project for which the budget is calculated
    cost_limit (float): The cost limit for the project's budget

Returns:
    float: The amount allocated to the project budget
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize the current sprint's tasks and add new task from meeting notes T to the current sprint[/INST]","var_1 = get_sprint_id()
var_2 = works_list(type=[""task""], owned_by=[var_1])
var_3 = summarize_objects(objects=var_2)
var_4 = create_actionable_tasks_from_text(text=""T"")
var_5 = add_work_items_to_sprint(work_ids=var_4, sprint_id=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""


def find_user_by_email(email):
""""""
Finds a user in the system by their email address

Parameters:
    email (str): The email address of the user to find

Returns:
    str: ID of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def archive_old_tickets(older_than_date, active_status=False):
""""""
Archives tickets that are older than the specified date, optionally filters by active status and returns the IDs

Parameters:
    older_than_date (str): A date in the format 'YYYY-MM-DD', to filter tickets older than this date
    active_status (bool): If True, only archives tickets that are currently active; defaults to False

Returns:
    str: ID of tickets archived
""""""


def generate_summary_report(object_ids):
""""""
Generates a summary report for the specified objects

Parameters:
    object_ids (list): A list of object IDs

Returns:
    str: The ID of the generated report
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def toggle_feature_access(feature_id, user_id, enable_access):
""""""
Toggles access to a specific feature for a user

Parameters:
    feature_id (str): The ID of the feature to toggle access
    user_id (str): The ID of the user whose access will be toggled
    enable_access (bool): 'True' to enable access, 'False' to disable

Returns:
    bool: The resulting access status
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks from the current sprint that are related to project PROJ-456[/INST]","var_1 = who_am_i()
var_2 = get_sprint_id()
var_3 = search_object_by_name(query=""PROJ-456"")
var_4 = works_list(owned_by=[var_1], applies_to_part=[var_3], type=[""task""])
var_5 = summarize_objects(objects=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""


def assign_tasks_to_employee(task_ids, employee_id):
""""""
Assigns a list of tasks to the specified employee

Parameters:
    task_ids (list): A list of task IDs to be assigned
    employee_id (str): The ID of the employee to whom the tasks will be assigned

Returns:
    bool: True if the assignment was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def list_all_blocked_tickets():
""""""
Lists all tickets that are currently blocked

Returns:
    list: Ticket IDs that are currently blocked
""""""


def generate_project_summary(project_id):
""""""
Generates a summary report for the specified project

Parameters:
    project_id (str): The ID of the project to summarize

Returns:
    str: A summary report of the project
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_sprint_history(sprint_id):
""""""
Retrieves the change history of a sprint

Parameters:
    sprint_id (str): The ID of the ticket

Returns:
    list: A list of changes made to the sprint
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
         Find issues with priority P2 related to part CLOUD-SERVICES, summarize them, and limit the results to 28.[/INST]","var_1 = works_list(applies_to_part=[""CLOUD-SERVICES""], issue.priority=[""p2""], type=[""issue""], limit=28)
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_progress_report(project_id, report_format=""summary""):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which the progress report is needed
    report_format (str): The format of the report; 'summary' or 'detailed'. The default is 'summary'

Returns:
    str: The generated progress report
""""""
def update_issue_status(issue_id, new_status):
""""""
Updates the status of an issue

Parameters:
    issue_id (str): The ID of the issue to be updated
    new_status (str): The new status to be set for the issue. Allowed values: open, in_progress, resolved, closed

Returns:
    bool: True if the update was successful, False otherwise
""""""


def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_summary_report(object_ids):
""""""
Generates a summary report for the specified objects

Parameters:
    object_ids (list): A list of object IDs

Returns:
    str: The ID of the generated report
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_sprint_history(sprint_id):
""""""
Retrieves the change history of a sprint

Parameters:
    sprint_id (str): The ID of the ticket

Returns:
    list: A list of changes made to the sprint
""""""


def generate_unique_identifier(prefix, use_timestamp=True):
""""""
Generates a unique identifier with an optional timestamp

Parameters:
    prefix (str): A prefix for the identifier
    use_timestamp (bool): If true, appends a timestamp to the prefix; defaults to True

Returns:
    str: The generated unique identifier
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create a list of tasks based on meeting notes and summarize the new tasks[/INST]","var_1 = create_actionable_tasks_from_text(text=""meeting notes"")
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_progress_report(project_id, report_format=""summary""):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which the progress report is needed
    report_format (str): The format of the report; 'summary' or 'detailed'. The default is 'summary'

Returns:
    str: The generated progress report
""""""


def convert_task_to_subtask(task_id, parent_task_id):
""""""
Converts a standalone task into a subtask of another task

Parameters:
    task_id (str): The ID of the task to be converted
    parent_task_id (str): The ID of the parent task to which the subtask will be linked

Returns:
    bool: True if the conversion was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_status(work_item_id, status_options):
""""""
Checks if the given work item has a status that is among the provided options

Parameters:
    work_item_id (str): The ID of the work item to check
    status_options (list): A list of valid status options

Returns:
    bool: True if status is valid, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For the Rev organization 'REV-789', list all tasks, prioritize them, and summarize for the report [/INST]","var_1 = search_object_by_name(query=""REV-789"")
var_2 = works_list(issue.rev_orgs=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_workload(user_id):
""""""
Retrieves the current workload for the specified user

Parameters:
    user_id (str): The ID of the user whose workload is to be retrieved

Returns:
    list: A list containing workload details
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def reassign_work_item_owner(work_id, new_owner_id):
""""""
Reassigns the owner of a work item to a new user

Parameters:
    work_id (str): The ID of the work item to be reassigned
    new_owner_id (str): The user ID of the new owner

Returns:
    bool: True if reassignment is successful, False otherwise
""""""


def calculate_progress_percentage(project_id):
""""""
Calculates the progress percentage of the given project

Parameters:
    project_id (str): The ID of the project for which to calculate progress

Returns:
    float: The percentage of project completion
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def filter_projects_by_status(project_ids, status=""active""):
""""""
Filters a list of project IDs by their status

Parameters:
    project_ids (list): A list of project IDs to filter
    status (str): The status to filter by, default is 'active'

Returns:
    list: Project IDs matching the status
""""""


def generate_summary_report(object_ids):
""""""
Generates a summary report for the specified objects

Parameters:
    object_ids (list): A list of object IDs

Returns:
    str: The ID of the generated report
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def assign_tasks_to_user(task_ids, user_id):
""""""
Assigns a list of task IDs to the provided user

Parameters:
    task_ids (list): List of task IDs to be assigned
    user_id (str): The ID of the user to whom the tasks will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_work_left(project_id):
""""""
Calculates the estimated amount of work left in a project

Parameters:
    project_id (str): The ID of the project to calculate work for

Returns:
    float: Estimated hours of work left
""""""


def update_contact_info(contact_id, new_email=None, new_phone=None):
""""""
Updates the contact information for a given contact ID with new email and/or phone

Parameters:
    contact_id (str): The ID of the contact to update
    new_email (str, optional): The new email address; defaults to None
    new_phone (str, optional): The new phone number; defaults to None

Returns:
    bool: True if the update was successful; otherwise False
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add all tasks related to the Epic EPIC-789 to the current sprint[/INST]","var_1 = search_object_by_name(query=""EPIC-789"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_progress_report(project_id, report_format=""summary""):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which the progress report is needed
    report_format (str): The format of the report; 'summary' or 'detailed'. The default is 'summary'

Returns:
    str: The generated progress report
""""""


def list_recent_activities(user_id, limit=10):
""""""
Lists the most recent activities performed by a user

Parameters:
    user_id (str): The ID of the user whose activities are to be listed
    limit (int): The maximum number of recent activities to return

Returns:
    list: Recent activities of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""


def calculate_project_completion_rate(project_id):
""""""
Calculates the completion rate of tasks for a given project

Parameters:
    project_id (str): The ID of the project to calculate the completion rate for

Returns:
    float: The completion rate as a percentage
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def link_related_tickets(ticket_id, related_ids):
""""""
Links tickets that are related to each other

Parameters:
    ticket_id (str): The ID of the ticket that will be linked with related tickets
    related_ids (list): List of IDs for tickets that are related to the original ticket

Returns:
    bool: True if the linking is successful, False otherwise
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def schedule_meeting_with_user(user_id, duration=30, urgent=False):
""""""
Schedules a meeting with a specified user

Parameters:
    user_id (str): The ID of the user with whom to schedule a meeting
    duration (int): Duration of the meeting in minutes, default is '30'
    urgent (bool): Whether the meeting is urgent, defaults to False

Returns:
    str: The ID of the scheduled meeting
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Locate work items for the 'QA-Testing' stage and assign to John Doe.[/INST]","var_1 = search_object_by_name(query=""John Doe"")
var_2 = works_list(stage.name=[""QA-Testing""], type=[""task""])
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_workload(user_id):
""""""
Retrieves the current workload for the specified user

Parameters:
    user_id (str): The ID of the user whose workload is to be retrieved

Returns:
    list: A list containing workload details
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a given date range.

Parameters:
    start_date (str): The start date of the desired date range
    end_date (str): The end date of the desired date range
    work_type (list): Optional filter for type of work

Returns:
    list: Work items within the specified date range
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_user_workload(user_id):
""""""
Calculates the workload of a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be calculated

Returns:
    float: The calculated workload value
""""""


def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""


def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""


def mark_item_as_duplicated(work_item_id, duplicate_of_id):
""""""
Marks a work item as a duplicate of another

Parameters:
    work_item_id (str): The ID of the work item that is a duplicate
    duplicate_of_id (str): The ID of the work item of which it is a duplicate

Returns:
    bool: True if the item is successfully marked, False otherwise
""""""


def get_team_member_list(team_id):
""""""
Retrieves a list of team members for the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: List of team member IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all work items with type ""issue"" that involve Rev organization ""REV-456"", prioritize and add to sprint ""SPRINT-123""[/INST]","var_1 = works_list(issue.rev_orgs=[""REV-456""], type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=""SPRINT-123"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""


def validate_user_permissions(user_id, required_permissions):
""""""
Checks if the user has the specified permissions

Parameters:
    user_id (str): The ID of the user whose permissions need to be checked
    required_permissions (list): A list of permissions to check against the user's permissions

Returns:
    bool: True if the user has all the required permissions, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def get_user_permissions(user_id):
""""""
Returns a list of permissions for a specified user ID

Parameters:
    user_id (str): The ID of the user whose permissions you want to retrieve

Returns:
    list: User permissions
""""""


def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def merge_duplicate_records(primary_record_id, duplicate_record_id):
""""""
Merges a duplicate record into a primary record

Parameters:
    primary_record_id (str): The ID of the primary record to keep
    duplicate_record_id (str): The ID of the duplicate record to merge

Returns:
    bool: True if the merge was successful; otherwise False
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def merge_duplicate_objects(primary_object_id, duplicate_object_id):
""""""
Merges a duplicate object into a primary object

Parameters:
    primary_object_id (str): The ID of the primary object
    duplicate_object_id (str): The ID of the duplicate object to be merged

Returns:
    bool: True if the merge was successful, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def fetch_user_tasks(user_id, include_completed=False):
""""""
Retrieves a list of tasks assigned to a user

Parameters:
    user_id (str): The ID of the user whose tasks are to be fetched
    include_completed (bool): Whether to include completed tasks in the list

Returns:
    list: List of tasks assigned to the user
""""""


def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize all tickets needing a response from the customer with the ID ""CUSTOMER-456""[/INST]","var_1 = search_object_by_name(query=""CUSTOMER-456"")
var_2 = works_list(ticket.rev_org=[var_1], ticket.needs_response=True, type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def filter_projects_by_status(project_ids, status=""active""):
""""""
Filters a list of project IDs by their status

Parameters:
    project_ids (list): A list of project IDs to filter
    status (str): The status to filter by, default is 'active'

Returns:
    list: Project IDs matching the status
""""""


def calculate_estimate_completion_time(work_id):
""""""
Calculates the estimated completion time for the specified work item

Parameters:
    work_id (str): The ID of the work item to calculate the estimated time

Returns:
    float: Estimated completion time in hours
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def deactivate_user_account(user_id, reason):
""""""
Deactivates a user account for a specific reason

Parameters:
    user_id (str): The ID of the user whose account is to be deactivated
    reason (str): The reason for deactivating the account

Returns:
    bool: True if the account was successfully deactivated; otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_estimated_effort(work_id):
""""""
Calculates the estimated effort required to complete a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    float: Estimated effort in hours
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find tasks similar to the one with ID ""BUG-456"" and summarize them for the weekly review[/INST]","var_1 = get_similar_work_items(work_id=""BUG-456"")
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List my tasks and arrange them by priority[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""


def remove_object_from_archive(object_id):
""""""
Removes an object from the system archive, making it active again

Parameters:
    object_id (str): The ID of the object to be removed from the archive

Returns:
    bool: True if the object was successfully removed, False otherwise
""""""


def assign_tasks_to_employee(task_ids, employee_id):
""""""
Assigns a list of tasks to the specified employee

Parameters:
    task_ids (list): A list of task IDs to be assigned
    employee_id (str): The ID of the employee to whom the tasks will be assigned

Returns:
    bool: True if the assignment was successful, False otherwise
""""""


def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def find_user_by_email(email):
""""""
Finds a user in the system by their email address

Parameters:
    email (str): The email address of the user to find

Returns:
    str: ID of the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a given date range.

Parameters:
    start_date (str): The start date of the desired date range
    end_date (str): The end date of the desired date range
    work_type (list): Optional filter for type of work

Returns:
    list: Work items within the specified date range
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks related to the ""Widget"" project and determine if any need my response[/INST]","var_1 = who_am_i()
var_2 = search_object_by_name(query=""Widget"")
var_3 = works_list(type=[""task""], owned_by=[var_1], applies_to_part=[var_2], ticket.needs_response=True)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_budget_remaining(budget_id):
""""""
Calculates the remaining budget for a given budget ID

Parameters:
    budget_id (str): The ID of the budget to calculate

Returns:
    float: The amount of remaining budget
""""""


def link_related_objects(object_id, related_object_id):
""""""
Creates a link between two related objects in the system

Parameters:
    object_id (str): The ID of the primary object
    related_object_id (str): The ID of the object to relate to the primary

Returns:
    bool: True if the objects were successfully linked, False otherwise
""""""


def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""


def fetch_user_created_work(user_id, work_type=None):
""""""
Retrieves work items created by a specific user

Parameters:
    user_id (str): The ID of the user whose work items are to be retrieved
    work_type (list): Filters for work of the provided types, e.g., ['issue', 'ticket']

Returns:
    list: Work items created by the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def assign_ticket_to_user(ticket_id, user_id):
""""""
Assigns a specific ticket to a user

Parameters:
    ticket_id (str): The ID of the ticket to be assigned
    user_id (str): The ID of the user to whom the ticket will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a given date range.

Parameters:
    start_date (str): The start date of the desired date range
    end_date (str): The end date of the desired date range
    work_type (list): Optional filter for type of work

Returns:
    list: Work items within the specified date range
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Fetch tickets from the email channel for organization ORG-456 and prioritize them[/INST]","var_1 = works_list(ticket.source_channel=[""email""], ticket.rev_org=[""ORG-456""], type=[""ticket""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify tasks for ENH-456 and summarize them[/INST]","var_1 = works_list(applies_to_part=[""ENH-456""], type=[""task""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize tasks related to the Epic EPIC-456[/INST]","var_1 = search_object_by_name(query=""EPIC-456"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def fetch_users_from_group(group_id):
""""""
Retrieves a list of user IDs that belong to the specified group

Parameters:
    group_id (str): The ID of the group

Returns:
    list: User IDs belonging to the group
""""""


def list_department_members(department_id):
""""""
Returns a list of user IDs for all members within a specified department

Parameters:
    department_id (str): The ID of the department to list members for

Returns:
    list: User IDs of all the members in the department
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize all p2 issues that need a response under REV-456[/INST]","var_1 = search_object_by_name(query=""REV-456"")
var_2 = works_list(issue.priority=[""p2""], ticket.needs_response=True, issue.rev_orgs=[var_1], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def link_related_objects(object_id, related_object_id):
""""""
Creates a link between two related objects in the system

Parameters:
    object_id (str): The ID of the primary object
    related_object_id (str): The ID of the object to relate to the primary

Returns:
    bool: True if the objects were successfully linked, False otherwise
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""


def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
         Prioritize and add to the current sprint all tasks related to part DATA-PIPELINE, limiting the results to 25.[/INST]","var_1 = works_list(applies_to_part=[""DATA-PIPELINE""], type=[""task""], limit=25)
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def validate_object_existence(object_id):
""""""
Checks if an object with the given ID exists in the system

Parameters:
    object_id (str): The ID of the object to check

Returns:
    bool: True if the object exists, otherwise False
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""


def remove_object_from_inventory(object_id):
""""""
Removes an object from the inventory system based on the object ID

Parameters:
    object_id (str): The ID of the object to remove from inventory

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_completed_tasks_by_user(user_id):
""""""
Lists all completed tasks for a specific user

Parameters:
    user_id (str): The ID of the user whose completed tasks need to be listed

Returns:
    list: List of completed task IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add all my tasks related to the 'UX-Redesign' project to the current sprint[/INST]","var_1 = who_am_i()
var_2 = search_object_by_name(query=""UX-Redesign"")
var_3 = works_list(applies_to_part=[var_2], owned_by=[var_1], type=[""task""])
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_user_permissions(user_id):
""""""
Lists all the permissions that a user has within the system

Parameters:
    user_id (str): The ID of the user for whom permissions are being listed

Returns:
    list: A list of permissions that the user possesses
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create a list of tasks based on the discussion points from the last team meeting and add them to my task list.[/INST]","var_1 = create_actionable_tasks_from_text(text=""discussion points from the last team meeting"")
var_2 = who_am_i()
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def find_work_items_by_tag(work_type, tag):
""""""
Finds work items of a certain type with a given tag

Parameters:
    work_type (str): The type of the work items to filter by
    tag (str): The tag to filter the work items

Returns:
    list: List of work items with the given tag
""""""


def remove_object_from_archive(object_id):
""""""
Removes an object from the system archive, making it active again

Parameters:
    object_id (str): The ID of the object to be removed from the archive

Returns:
    bool: True if the object was successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def filter_users_by_department(department_id=None, active_only=False):
""""""
Filters a list of users that belong to the specified department

Parameters:
    department_id (str): The ID of the department to filter users
    active_only (bool): Filters for only active users if set to True

Returns:
    list: Users in the specified department
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def list_user_skills(user_id):
""""""
Lists the skills associated with the specified user

Parameters:
    user_id (str): The ID of the user whose skills are being queried

Returns:
    list: The skills of the user
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def extract_contact_info(text_id, entity_type):
""""""
Extracts contact information from a text source based on a given entity type

Parameters:
    text_id (str): The ID of the text source from which to extract contact information
    entity_type (str): The type of entity to extract info from. Allowed values: 'individual', 'company'

Returns:
    list: Extracted contact information
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""


def merge_duplicate_tickets(primary_ticket_id, duplicate_ticket_ids):
""""""
Merges duplicate tickets into a primary ticket

Parameters:
    primary_ticket_id (str): The ID of the primary ticket that remains
    duplicate_ticket_ids (list): The IDs of the duplicate tickets to be merged into the primary

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify and summarize all tickets without a response that are tagged with ""Blocker""[/INST]","var_1 = works_list(ticket.needs_response=True, ticket.severity=[""blocker""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def update_issue_status(issue_id, new_status):
""""""
Updates the status of an issue

Parameters:
    issue_id (str): The ID of the issue to be updated
    new_status (str): The new status to be set for the issue. Allowed values: open, in_progress, resolved, closed

Returns:
    bool: True if the update was successful, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""


def check_inventory_availability(part_id, minimum_quantity=1):
""""""
Checks if the inventory has the specified part in at least the minimum quantity

Parameters:
    part_id (str): The ID of the part to check in inventory
    minimum_quantity (int): The minimum quantity to check for; defaults to 1

Returns:
    bool: True if the minimum quantity is available; otherwise False
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize all ""ticket"" type work items related to ""ProjectZ"" and add them to the sprint[/INST]","var_1 = search_object_by_name(query=""ProjectZ"")
var_2 = works_list(ticket.rev_org=[var_1], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def link_related_objects(object_id, related_object_id):
""""""
Creates a link between two related objects in the system

Parameters:
    object_id (str): The ID of the primary object
    related_object_id (str): The ID of the object to relate to the primary

Returns:
    bool: True if the objects were successfully linked, False otherwise
""""""


def batch_update_task_status(task_ids, new_status):
""""""
Updates the status of multiple tasks in a batch operation

Parameters:
    task_ids (list): A list of task IDs whose status needs updating
    new_status (str): The new status to apply to the tasks

Returns:
    bool: True if the update was successful, False otherwise
""""""


def convert_task_to_ticket(task_id):
""""""
Converts a task into a ticket in the system

Parameters:
    task_id (str): The ID of the task to be converted

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""


def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_project_timeline(project_id):
""""""
Retrieves the timeline and key milestones of a project

Parameters:
    project_id (str): The ID of the project for which the timeline is requested

Returns:
    list: Key milestones and dates for the project timeline
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Search for tasks from the ""Customer Feedback"" channel and list them by their creation date[/INST]","var_1 = works_list(type=[""task""], ticket.source_channel=[""Customer Feedback""])
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all tasks related to the ""BackendOptimization"" project and then add high-priority ones to the active sprint.[/INST]","var_1 = search_object_by_name(query=""BackendOptimization"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = get_sprint_id()
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def remove_object_from_inventory(object_id):
""""""
Removes an object from the inventory system based on the object ID

Parameters:
    object_id (str): The ID of the object to remove from inventory

Returns:
    bool: True if the removal was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def mark_ticket_for_review(ticket_id, reviewer_id):
""""""
Marks a ticket for review by a specific user

Parameters:
    ticket_id (str): The ID of the ticket to be marked for review
    reviewer_id (str): The ID of the user who should review the ticket

Returns:
    None
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For issues raised via email, get their IDs, summarize them, and identify if any are similar to ""ISSUE-999"".[/INST]","var_1 = works_list(ticket.source_channel=[""email""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_similar_work_items(work_id=""ISSUE-999"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_due_date(work_item_id, due_date):
""""""
Updates the due date for the specified work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    due_date (str): The new due date for the work item

Returns:
    None: Indicates that the operation was executed without returning any value
""""""


def generate_report_data(report_type, data_set_id):
""""""
Generates report data based on the provided report type and data set

Parameters:
    report_type (str): The type of report to generate
    data_set_id (str): The ID of the data set to be used for the report

Returns:
    str: A report data string or ID depending on internal implementation
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def get_user_workload(user_id):
""""""
Determines the current workload for a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be determined

Returns:
    int: The number of tasks assigned to the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def extract_contact_info(text_id, entity_type):
""""""
Extracts contact information from a text source based on a given entity type

Parameters:
    text_id (str): The ID of the text source from which to extract contact information
    entity_type (str): The type of entity to extract info from. Allowed values: 'individual', 'company'

Returns:
    list: Extracted contact information
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def check_inventory_availability(part_id, minimum_quantity=1):
""""""
Checks if the inventory has the specified part in at least the minimum quantity

Parameters:
    part_id (str): The ID of the part to check in inventory
    minimum_quantity (int): The minimum quantity to check for; defaults to 1

Returns:
    bool: True if the minimum quantity is available; otherwise False
""""""


def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize the recent work created by user ""DevX"" and identify which items need a response.[/INST]","var_1 = search_object_by_name(query=""DevX"")
var_2 = works_list(created_by=[var_1])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def convert_task_to_subtask(task_id, parent_task_id):
""""""
Converts a standalone task into a subtask of another task

Parameters:
    task_id (str): The ID of the task to be converted
    parent_task_id (str): The ID of the parent task to which the subtask will be linked

Returns:
    bool: True if the conversion was successful, False otherwise
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""


def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""


def get_user_contact_info(user_id):
""""""
Retrieves contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact information is requested

Returns:
    str: The contact information of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def reassign_work_item_owner(work_id, new_owner_id):
""""""
Reassigns the owner of a work item to a new user

Parameters:
    work_id (str): The ID of the work item to be reassigned
    new_owner_id (str): The user ID of the new owner

Returns:
    bool: True if reassignment is successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def get_recent_activity_log(user_id, limit=10):
""""""
Gets the most recent activity log entries for a given user

Parameters:
    user_id (str): The ID of the user to get activities for
    limit (int): The maximum number of activity log entries to return

Returns:
    list: Recent activity log entries
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_progress(project_id):
""""""
Calculates the overall progress of a given project as a percentage

Parameters:
    project_id (str): The ID of the project for which progress is being calculated

Returns:
    float: The progress percentage of the project
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_contact_information(contact_id, new_phone=None, new_email=None):
""""""
Updates the contact information with new provided phone number or email

Parameters:
    contact_id (str): The ID of the contact to update
    new_phone (str): The new phone number for the contact, default is 'None'
    new_email (str): The new email address for the contact, default is 'None'

Returns:
    bool: Status of the update operation
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create a summary report of all issues created by user 'Alex' that are in the 'QA Testing' stage[/INST]","var_1 = search_object_by_name(query=""Alex"")
var_2 = works_list(created_by=[var_1], stage.name=[""QA Testing""], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def update_issue_status(issue_id, new_status):
""""""
Updates the status of an issue

Parameters:
    issue_id (str): The ID of the issue to be updated
    new_status (str): The new status to be set for the issue. Allowed values: open, in_progress, resolved, closed

Returns:
    bool: True if the update was successful, False otherwise
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def filter_records_by_date(record_ids, start_date, end_date):
""""""
Filters a list of record IDs based on a date range

Parameters:
    record_ids (list): List of record IDs to filter
    start_date (str): Start date for the filtering in 'YYYY-MM-DD' format
    end_date (str): End date for the filtering in 'YYYY-MM-DD' format

Returns:
    list: Filtered record IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List and prioritize all P1 tickets for the Rev organization REV-TEAM-456[/INST]","var_1 = search_object_by_name(query=""REV-TEAM-456"")
var_2 = works_list(issue.rev_orgs=[var_1], issue.priority=[""p1""], type=[""ticket""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_user_permissions(user_id):
""""""
Lists all the permissions that a user has within the system

Parameters:
    user_id (str): The ID of the user for whom permissions are being listed

Returns:
    list: A list of permissions that the user possesses
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def assign_tickets_to_user(ticket_ids, user_id):
""""""
Assigns a set of tickets to a specified user

Parameters:
    ticket_ids (list): A list of ticket IDs to be assigned
    user_id (str): The ID of the user to whom the tickets will be assigned

Returns:
    None
""""""


def batch_update_user_roles(user_ids, new_role):
""""""
Updates the roles for a batch of users to a new role

Parameters:
    user_ids (list): List of user IDs whose roles should be updated
    new_role (str): The new role to assign

Returns:
    int: Number of users successfully updated
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def schedule_meeting_with_user(user_id, duration=30, urgent=False):
""""""
Schedules a meeting with a specified user

Parameters:
    user_id (str): The ID of the user with whom to schedule a meeting
    duration (int): Duration of the meeting in minutes, default is '30'
    urgent (bool): Whether the meeting is urgent, defaults to False

Returns:
    str: The ID of the scheduled meeting
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""
def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For the customer ""ClientX"", find all open tickets, prioritize by their severity, and assign to the sprint X[/INST]","var_1 = search_object_by_name(query=""ClientX"")
var_2 = works_list(ticket.rev_org=[var_1], type=[""ticket""])
var_3 = prioritize_objects(objects=var_2)
var_4 = search_object_by_name(query=""X"")
var_5 = add_work_items_to_sprint(work_ids=var_3, sprint_id=var_4)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_contact_info(user_id):
""""""
Retrieves the contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact info is requested

Returns:
    str: Contact information of the user
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_user_workload(user_id):
""""""
Calculates the workload of a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be calculated

Returns:
    float: The calculated workload value
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def toggle_feature_access(feature_id, user_id, enable_access):
""""""
Toggles access to a specific feature for a user

Parameters:
    feature_id (str): The ID of the feature to toggle access
    user_id (str): The ID of the user whose access will be toggled
    enable_access (bool): 'True' to enable access, 'False' to disable

Returns:
    bool: The resulting access status
""""""


def calculate_budget_allocation(project_id, cost_limit):
""""""
Calculates and assigns the budget allocation for a project

Parameters:
    project_id (str): The ID of the project for which the budget is calculated
    cost_limit (float): The cost limit for the project's budget

Returns:
    float: The amount allocated to the project budget
""""""


def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List and summarize all issues marked as p0 in priority that I own[/INST]","var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p0""], owned_by=[var_1], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def archive_completed_work(work_ids):
""""""
Archives a list of completed work items

Parameters:
    work_ids (list): A list of work item IDs that have been completed and need to be archived

Returns:
    int: The number of work items successfully archived
""""""


def merge_duplicate_work_items(primary_work_id, duplicate_work_ids):
""""""
Merges duplicate work items into the primary work item

Parameters:
    primary_work_id (str): The ID of the primary work item
    duplicate_work_ids (list): List of IDs of duplicate work items to be merged

Returns:
    bool: True if merge was successful, otherwise False
""""""


def calculate_expense_totals(expense_ids):
""""""
Calculates the total amount from a list of expense IDs

Parameters:
    expense_ids (list): List of expense IDs to calculate the total amount

Returns:
    float: The total amount of the expenses
""""""


def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_project_completion_rate(project_id):
""""""
Calculates the completion rate of tasks for a given project

Parameters:
    project_id (str): The ID of the project to calculate the completion rate for

Returns:
    float: The completion rate as a percentage
""""""


def calculate_effort_for_task(task_id):
""""""
Calculates the effort spent on a specific task by summing subtasks

Parameters:
    task_id (str): The ID of the task for which the effort needs to be calculated

Returns:
    float: Total effort spent on the task
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and summarize my work items with priority 'p2' that are pending in 'QA' stage[/INST]","var_1 = who_am_i()
var_2 = works_list(type=[""issue"", ""ticket"", ""task""], owned_by=[var_1], issue.priority=[""p2""], stage.name=[""QA""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_objects_by_type(object_ids, object_type):
""""""
Filters a list of objects based on their type

Parameters:
    object_ids (list): A list of object IDs to filter
    object_type (str): The type of objects to filter for

Returns:
    list: Filtered object IDs matching the specified type
""""""


def calculate_effort_for_task(task_id):
""""""
Calculates the effort spent on a specific task by summing subtasks

Parameters:
    task_id (str): The ID of the task for which the effort needs to be calculated

Returns:
    float: Total effort spent on the task
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def merge_duplicate_records(primary_record_id, duplicate_record_id):
""""""
Merges a duplicate record into a primary record

Parameters:
    primary_record_id (str): The ID of the primary record to keep
    duplicate_record_id (str): The ID of the duplicate record to merge

Returns:
    bool: True if the merge was successful; otherwise False
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_estimated_effort(work_id):
""""""
Calculates the estimated effort required to complete a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    float: Estimated effort in hours
""""""


def generate_unique_identifier(prefix, use_timestamp=True):
""""""
Generates a unique identifier with an optional timestamp

Parameters:
    prefix (str): A prefix for the identifier
    use_timestamp (bool): If true, appends a timestamp to the prefix; defaults to True

Returns:
    str: The generated unique identifier
""""""


def fetch_ticket_history(ticket_id, history_limit=10):
""""""
Fetches the history of changes to a given ticket

Parameters:
    ticket_id (str): The ID of the ticket for which the history is requested
    history_limit (int): Maximum number of history entries to retrieve. The default is '10'

Returns:
    list: A list of history records for the ticket
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
         Prioritize and summarize tickets that need a response from the CUSTOMER_SERVICE team, limiting the results to 22.[/INST]","var_1 = search_object_by_name(query=""CUSTOMER_SERVICE"")
var_2 = works_list(ticket.needs_response=True, ticket.rev_org=[var_1], limit=22)
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_system_event(event_type, description, user_id=None):
""""""
Logs an event in the system with an optional user ID associated with it

Parameters:
    event_type (str): The type of event to log
    description (str): A brief description of the event
    user_id (str): The ID of the user involved in the event, if applicable

Returns:
    str: The ID of the logged event
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def validate_user_permissions(user_id, required_permissions):
""""""
Checks if the user has the specified permissions

Parameters:
    user_id (str): The ID of the user whose permissions need to be checked
    required_permissions (list): A list of permissions to check against the user's permissions

Returns:
    bool: True if the user has all the required permissions, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_ticket_status(ticket_id, new_status):
""""""
Updates the status of a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to be updated
    new_status (str): The new status to update the ticket with

Returns:
    bool: True if the update was successful, otherwise False
""""""


def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and sort issues of type 'task' that need a response[/INST]","var_1 = works_list(ticket.needs_response=True, type=[""task""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize all P1 tickets from the support channel 'email' that are pending review[/INST]","var_1 = works_list(ticket.severity=[""p1""], ticket.source_channel=[""email""], stage.name=[""pending review""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_due_date(work_item_id, due_date):
""""""
Updates the due date for the specified work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    due_date (str): The new due date for the work item

Returns:
    None: Indicates that the operation was executed without returning any value
""""""


def retrieve_user_workload(user_id):
""""""
Retrieves the current workload for the specified user

Parameters:
    user_id (str): The ID of the user whose workload is to be retrieved

Returns:
    list: A list containing workload details
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def validate_user_permissions(user_id, required_permissions):
""""""
Checks if the user has the specified permissions

Parameters:
    user_id (str): The ID of the user whose permissions need to be checked
    required_permissions (list): A list of permissions to check against the user's permissions

Returns:
    bool: True if the user has all the required permissions, False otherwise
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def get_object_history(object_id):
""""""
Retrieves the change history of a specified object

Parameters:
    object_id (str): The ID of the object for which history is requested

Returns:
    list: A list of changes made to the object
""""""


def validate_work_item_status(work_item_id, status_options):
""""""
Checks if the given work item has a status that is among the provided options

Parameters:
    work_item_id (str): The ID of the work item to check
    status_options (list): A list of valid status options

Returns:
    bool: True if status is valid, False otherwise
""""""


def merge_duplicate_tickets(primary_ticket_id, duplicate_ticket_ids):
""""""
Merges duplicate tickets into a primary ticket

Parameters:
    primary_ticket_id (str): The ID of the primary ticket that remains
    duplicate_ticket_ids (list): The IDs of the duplicate tickets to be merged into the primary

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List and summarize my tasks associated with Rev organization REV-456[/INST]","var_1 = who_am_i()
var_2 = search_object_by_name(query=""REV-456"")
var_3 = works_list(owned_by=[var_1], ticket.rev_org=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""


def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a specific date range

Parameters:
    start_date (str): The start date for the filter range (format: YYYY-MM-DD)
    end_date (str): The end date for the filter range (format: YYYY-MM-DD)
    work_type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Work items in the specified date range
""""""


def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize the open issues from the Engineering team with priority P2[/INST]","var_1 = works_list(issue.priority=[""p2""], stage.name=[""open""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def reassign_work_item_owner(work_id, new_owner_id):
""""""
Reassigns the owner of a work item to a new user

Parameters:
    work_id (str): The ID of the work item to be reassigned
    new_owner_id (str): The user ID of the new owner

Returns:
    bool: True if reassignment is successful, False otherwise
""""""


def calculate_effort_for_task(task_id):
""""""
Calculates the effort spent on a specific task by summing subtasks

Parameters:
    task_id (str): The ID of the task for which the effort needs to be calculated

Returns:
    float: Total effort spent on the task
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def estimate_time_for_task(task_id, estimation_hours):
""""""
Updates a task with a time estimation

Parameters:
    task_id (str): The ID of the task to be updated with an estimated time
    estimation_hours (float): The estimated time in hours to complete the task

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve work items for part CAPL-123, filter by P1 priority, and summarize the results[/INST]","var_1 = search_object_by_name(query=""CAPL-123"")
var_2 = works_list(applies_to_part=[var_1], issue.priority=[""p1""], type=[""issue"", ""ticket"", ""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""


def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""


def list_recent_activities(user_id, limit=10):
""""""
Lists the most recent activities performed by a user

Parameters:
    user_id (str): The ID of the user whose activities are to be listed
    limit (int): The maximum number of recent activities to return

Returns:
    list: Recent activities of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def estimate_task_duration(task_id, complexity_level):
""""""
Estimates the duration needed to complete a task based on its complexity level

Parameters:
    task_id (str): The ID of the task
    complexity_level (str): The complexity level of the task. Allowed values: 'low', 'medium', 'high'

Returns:
    float: Estimated duration in hours
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a given date range.

Parameters:
    start_date (str): The start date of the desired date range
    end_date (str): The end date of the desired date range
    work_type (list): Optional filter for type of work

Returns:
    list: Work items within the specified date range
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize and add new feature requests to the product backlog.[/INST]","var_1 = works_list(type=[""new feature request""], type=[""task""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_time_until_deadline(work_item_id):
""""""
Calculates the amount of time remaining until the deadline of a work item

Parameters:
    work_item_id (str): The ID of the work item

Returns:
    float: The number of hours until the deadline
""""""



def log_system_activity(activity_description, user_id=None):
""""""
Logs a system activity with an optional user ID

Parameters:
    activity_description (str): A brief description of the activity being logged
    user_id (str, optional): The ID of the user associated with the activity; defaults to None

Returns:
    bool: True if the activity was logged successfully; otherwise False
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""

def assign_ticket_to_user(ticket_id, user_id):
""""""
Assigns a specific ticket to a user

Parameters:
    ticket_id (str): The ID of the ticket to be assigned
    user_id (str): The ID of the user to whom the ticket will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def filter_projects_by_status(project_ids, status=""active""):
""""""
Filters a list of project IDs by their status

Parameters:
    project_ids (list): A list of project IDs to filter
    status (str): The status to filter by, default is 'active'

Returns:
    list: Project IDs matching the status
""""""


def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""

def fetch_user_tasks(user_id, include_completed=False):
""""""
Retrieves a list of tasks assigned to a user

Parameters:
    user_id (str): The ID of the user whose tasks are to be fetched
    include_completed (bool): Whether to include completed tasks in the list

Returns:
    list: List of tasks assigned to the user
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""


def get_team_member_list(team_id):
""""""
Retrieves a list of team members for the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: List of team member IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List all high severity tickets coming in from slack from customer Cust123 and generate a summary of them.[/INST]","var_1 = search_object_by_name(query=""Cust123"")
var_2 = works_list(ticket.severity=[""high""], ticket.source_channel=[""slack""], ticket.rev_org=[var_1], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find tasks for the ""Alpha"" project and sort them by priority[/INST]","var_1 = search_object_by_name(query=""Alpha"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_work_by_date_range(start_date, end_date, work_type=None):
""""""
Filters work items based on a specific date range

Parameters:
    start_date (str): The start date for the filter range (format: YYYY-MM-DD)
    end_date (str): The end date for the filter range (format: YYYY-MM-DD)
    work_type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Work items in the specified date range
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def reassign_work_item_owner(work_id, new_owner_id):
""""""
Reassigns the owner of a work item to a new user

Parameters:
    work_id (str): The ID of the work item to be reassigned
    new_owner_id (str): The user ID of the new owner

Returns:
    bool: True if reassignment is successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize and summarize my open tickets[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], type=[""ticket""])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_contact_info(user_id):
""""""
Retrieves the contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact info is requested

Returns:
    str: Contact information of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def filter_tickets_by_date(ticket_ids, start_date, end_date=None):
""""""
Filters a list of ticket IDs based on a date range

Parameters:
    ticket_ids (list): A list of ticket IDs to filter
    start_date (str): The start date for the range
    end_date (str, optional): The end date for the range, defaults to None

Returns:
    list: Filtered list of ticket IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Can you translate the phrase ""Hello, how are you?"" into French?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_due_date(work_item_id, due_date):
""""""
Updates the due date for the specified work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    due_date (str): The new due date for the work item

Returns:
    None: Indicates that the operation was executed without returning any value
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def filter_users_by_department(department_id=None, active_only=False):
""""""
Filters a list of users that belong to the specified department

Parameters:
    department_id (str): The ID of the department to filter users
    active_only (bool): Filters for only active users if set to True

Returns:
    list: Users in the specified department
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_work_left(project_id):
""""""
Calculates the estimated amount of work left in a project

Parameters:
    project_id (str): The ID of the project to calculate work for

Returns:
    float: Estimated hours of work left
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What is the plot summary of the novel ""1984"" by George Orwell?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        def update_issue_status(issue_id, new_status):
""""""
Updates the status of an issue

Parameters:
    issue_id (str): The ID of the issue to be updated
    new_status (str): The new status to be set for the issue. Allowed values: open, in_progress, resolved, closed

Returns:
    bool: True if the update was successful, False otherwise
""""""


def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def retrieve_sprint_workload(sprint_id):
""""""
Calculates the total workload for a given sprint based on the work items associated with it

Parameters:
    sprint_id (str): The ID of the sprint for workload calculation

Returns:
    float: Total workload in hours
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all P1 tasks related to the REV-456 organization and organize them by priority[/INST]","var_1 = works_list(issue.rev_orgs=[""REV-456""], issue.priority=[""p1""], type=[""task""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def fetch_users_from_group(group_id):
""""""
Retrieves a list of user IDs that belong to the specified group

Parameters:
    group_id (str): The ID of the group

Returns:
    list: User IDs belonging to the group
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def estimate_task_duration(task_id, complexity_level):
""""""
Estimates the duration needed to complete a task based on its complexity level

Parameters:
    task_id (str): The ID of the task
    complexity_level (str): The complexity level of the task. Allowed values: 'low', 'medium', 'high'

Returns:
    float: Estimated duration in hours
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_summary_report(object_ids):
""""""
Generates a summary report for the specified objects

Parameters:
    object_ids (list): A list of object IDs

Returns:
    str: The ID of the generated report
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def filter_records_by_date(record_ids, start_date, end_date):
""""""
Filters a list of record IDs based on a date range

Parameters:
    record_ids (list): List of record IDs to filter
    start_date (str): Start date for the filtering in 'YYYY-MM-DD' format
    end_date (str): End date for the filtering in 'YYYY-MM-DD' format

Returns:
    list: Filtered record IDs
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        
Summarize the work items that are at the 'review' stage and created by user USR-123
[/INST]","var_1 = works_list(stage.name=[""review""], created_by=[""USR-123""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""


def remove_user_from_project(user_id, project_id):
""""""
Removes a user from a project

Parameters:
    user_id (str): The ID of the user to be removed
    project_id (str): The ID of the project from which the user is to be removed

Returns:
    bool: True if the user is successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_effort_for_task(task_id):
""""""
Calculates the effort spent on a specific task by summing subtasks

Parameters:
    task_id (str): The ID of the task for which the effort needs to be calculated

Returns:
    float: Total effort spent on the task
""""""


def list_completed_tasks_by_user(user_id, project_id=None):
""""""
Lists all tasks completed by a given user, optionally filtered by project

Parameters:
    user_id (str): The ID of the user
    project_id (str, optional): The ID of the project to filter tasks

Returns:
    list: List of task IDs completed by the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def link_related_documents(doc_id, related_doc_ids):
""""""
Links related documents to the given document in the system

Parameters:
    doc_id (str): The ID of the document to which related documents should be linked
    related_doc_ids (list): A list of IDs for related documents

Returns:
    bool: True if the operation was successful, False otherwise
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def deactivate_user_account(user_id, reason):
""""""
Deactivates a user account for a specific reason

Parameters:
    user_id (str): The ID of the user whose account is to be deactivated
    reason (str): The reason for deactivating the account

Returns:
    bool: True if the account was successfully deactivated; otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add recent issues created by user USER-456 to the current sprint[/INST]","var_1 = works_list(created_by=[""USER-456""], type=[""issue""])
var_2 = get_sprint_id()
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""


def convert_task_to_ticket(task_id):
""""""
Converts a task into a ticket in the system

Parameters:
    task_id (str): The ID of the task to be converted

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def assign_tickets_to_user(ticket_ids, user_id):
""""""
Assigns a set of tickets to a specified user

Parameters:
    ticket_ids (list): A list of ticket IDs to be assigned
    user_id (str): The ID of the user to whom the tickets will be assigned

Returns:
    None
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Is there a balance between order and chaos, or is one ultimately dominant?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def calculate_work_item_duration(work_id):
""""""
Calculates the total time taken to complete a work item

Parameters:
    work_id (str): The ID of the work item for which duration is to be calculated

Returns:
    float: The total duration in hours
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve all tickets needing a response, summarize by the issue and identify if any are critical[/INST]","var_1 = works_list(type=[""ticket""], ticket.needs_response=True)
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def track_time_on_task(task_id, hours_spent):
""""""
Tracks time spent on a task by logging the number of hours

Parameters:
    task_id (str): The ID of the task on which time is spent
    hours_spent (float): The number of hours spent on the task

Returns:
    bool: Status of the time tracking
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create a summary of all p1 tickets owned by user DEVU-456[/INST]","var_1 = works_list(owned_by=[""DEVU-456""], ticket.severity=[""p1""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def archive_completed_work(work_ids):
""""""
Archives a list of completed work items

Parameters:
    work_ids (list): A list of work item IDs that have been completed and need to be archived

Returns:
    int: The number of work items successfully archived
""""""


def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""


def validate_object_existence(object_id):
""""""
Checks if an object with the given ID exists in the system

Parameters:
    object_id (str): The ID of the object to check

Returns:
    bool: True if the object exists, otherwise False
""""""


def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""
def link_issues_to_project(issue_ids, project_id):
""""""
Links the given issues to the specified project

Parameters:
    issue_ids (list): A list of issue IDs to be linked to the project
    project_id (str): The ID of the project to which the issues should be linked

Returns:
    bool: Status of the linking action
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""


def filter_projects_by_category(category_id, active_only=True):
""""""
Filters projects by their category and returns a list of project IDs

Parameters:
    category_id (str): The ID of the category to filter projects by
    active_only (bool): Whether to return only active projects

Returns:
    list: List of project IDs matching the category filter
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def calculate_due_dates(work_item_ids, urgency_level):
""""""
Calculates the due dates for given work items based on their urgency

Parameters:
    work_item_ids (list): A list of work item IDs for which due dates are required
    urgency_level (str): The urgency level. Allowed values: 'high', 'medium', 'low'

Returns:
    list: Due dates for the specified work items
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks which need a response and prioritize them[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], ticket.needs_response=True, type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_due_date(work_item_id, due_date):
""""""
Updates the due date for the specified work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    due_date (str): The new due date for the work item

Returns:
    None: Indicates that the operation was executed without returning any value
""""""


def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def archive_completed_tasks(project_id, completed_since):
""""""
Archives tasks that are completed within the given project since the specified time

Parameters:
    project_id (str): The ID of the project containing the tasks
    completed_since (str): Archive tasks completed after this timestamp

Returns:
    int: Number of tasks archived
""""""


def list_user_tasks(user_id, completed=False):
""""""
Lists all tasks assigned to a user, optionally filtering for completed tasks

Parameters:
    user_id (str): The ID of the user whose tasks are to be listed
    completed (bool): If True, only completed tasks are returned

Returns:
    list: A list of tasks assigned to the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def log_user_activity(user_id, activity_description):
""""""
Logs a user's activity with a description

Parameters:
    user_id (str): The ID of the user whose activity is being logged
    activity_description (str): A description of the activity

Returns:
    bool: True if the logging was successful, False otherwise
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve the current sprint ID and assign newly created tasks from the brainstorming session notes[/INST]","var_1 = create_actionable_tasks_from_text(text=""brainstorming session notes"")
var_2 = get_sprint_id()
var_3 = add_work_items_to_sprint(work_ids=var_1, sprint_id=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def log_system_event(event_type, description, user_id=None):
""""""
Logs an event in the system with an optional user ID associated with it

Parameters:
    event_type (str): The type of event to log
    description (str): A brief description of the event
    user_id (str): The ID of the user involved in the event, if applicable

Returns:
    str: The ID of the logged event
""""""


def retrieve_archived_documents(archive_id, keyword=None):
""""""
Retrieves documents from the archive based on optional keyword

Parameters:
    archive_id (str): The ID of the archive from which to retrieve documents
    keyword (str): Optional keyword to filter documents, default is 'None'

Returns:
    list: A list of documents matching the keyword if provided, otherwise all documents from the archive
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def get_user_workload(user_id):
""""""
Determines the current workload for a user based on assigned tasks

Parameters:
    user_id (str): The ID of the user whose workload is to be determined

Returns:
    int: The number of tasks assigned to the user
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify my p1 issues within Rev organization 'REV-789' and summarize for today's meeting[/INST]","var_1 = who_am_i()
var_2 = search_object_by_name(query=""REV-789"")
var_3 = works_list(owned_by=[var_1], issue.priority=[""p1""], issue.rev_orgs=[var_2], type=[""issue""])
var_4 = summarize_objects(objects=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_workload(user_id):
""""""
Retrieves the current workload for the specified user

Parameters:
    user_id (str): The ID of the user whose workload is to be retrieved

Returns:
    list: A list containing workload details
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def assign_ticket_to_user(ticket_id, user_id):
""""""
Assigns a specific ticket to a user

Parameters:
    ticket_id (str): The ID of the ticket to be assigned
    user_id (str): The ID of the user to whom the ticket will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_work_left(project_id):
""""""
Calculates the estimated amount of work left in a project

Parameters:
    project_id (str): The ID of the project to calculate work for

Returns:
    float: Estimated hours of work left
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_contact_info(contact_id, new_email=None, new_phone=None):
""""""
Updates the contact information for a given contact ID with new email and/or phone

Parameters:
    contact_id (str): The ID of the contact to update
    new_email (str, optional): The new email address; defaults to None
    new_phone (str, optional): The new phone number; defaults to None

Returns:
    bool: True if the update was successful; otherwise False
""""""


def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""


def generate_report_from_template(report_template_id, data_source_id):
""""""
Generates a report based on a specified template and data source

Parameters:
    report_template_id (str): The ID of the report template to use
    data_source_id (str): The ID of the data source

Returns:
    str: Generated report
""""""
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        List all P2 priority tickets from the product PROD-789 and add them to the current sprint.[/INST]","var_1 = search_object_by_name(query=""PROD-789"")
var_2 = works_list(applies_to_part=[var_1], issue.priority=[""p2""], type=[""ticket""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def merge_duplicate_tickets(primary_ticket_id, duplicate_ticket_ids):
""""""
Merges duplicate tickets into a primary ticket

Parameters:
    primary_ticket_id (str): The ID of the primary ticket that remains
    duplicate_ticket_ids (list): The IDs of the duplicate tickets to be merged into the primary

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add my new high severity tickets with part 'part-123' to the current sprint[/INST]","var_1 = who_am_i()
var_2 = works_list(type=[""ticket""], ticket.severity=[""high""], applies_to_part=['part-123'], owned_by=[var_1])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def filter_tasks_by_completion(task_ids, completed=True):
""""""
Filters the list of tasks by their completion status

Parameters:
    task_ids (list): List of task IDs to filter
    completed (bool): The completion status to filter by. Default is 'True'

Returns:
    list: List of task IDs that match the completion status
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def extract_contact_info(text_id, entity_type):
""""""
Extracts contact information from a text source based on a given entity type

Parameters:
    text_id (str): The ID of the text source from which to extract contact information
    entity_type (str): The type of entity to extract info from. Allowed values: 'individual', 'company'

Returns:
    list: Extracted contact information
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Search for part ID ""PartX"" and list all associated tasks[/INST]","var_1 = search_object_by_name(query=""PartX"")
var_2 = works_list(applies_to_part=[var_1], type=[""task""])
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize my tasks that need a response in the 'development' stage.[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""development""], ticket.needs_response=True, type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def reassign_work_item_owner(work_id, new_owner_id):
""""""
Reassigns the owner of a work item to a new user

Parameters:
    work_id (str): The ID of the work item to be reassigned
    new_owner_id (str): The user ID of the new owner

Returns:
    bool: True if reassignment is successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_work_item_history(work_id):
""""""
Retrieves the history of changes for a given work item

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: A chronological list of changes made to the work item
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def allocate_resources_to_project(project_id, resource_ids):
""""""
Allocates specified resources to a project

Parameters:
    project_id (str): The ID of the project to which resources are allocated
    resource_ids (list): A list of resource IDs to allocate to the project

Returns:
    bool: True if resources could be allocated, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Could the complexity of the universe be a reflection of the intricacies of the human mind?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def list_user_permissions(user_id):
""""""
Lists all the permissions that a user has within the system

Parameters:
    user_id (str): The ID of the user for whom permissions are being listed

Returns:
    list: A list of permissions that the user possesses
""""""


def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def filter_projects_by_category(category_id, active_only=True):
""""""
Filters projects by their category and returns a list of project IDs

Parameters:
    category_id (str): The ID of the category to filter projects by
    active_only (bool): Whether to return only active projects

Returns:
    list: List of project IDs matching the category filter
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
    task_id (str): The ID of the task to be marked as complete

Returns:
    bool: True if marked successfully, False otherwise
""""""


def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""


def validate_work_item_status(work_item_id, status_options):
""""""
Checks if the given work item has a status that is among the provided options

Parameters:
    work_item_id (str): The ID of the work item to check
    status_options (list): A list of valid status options

Returns:
    bool: True if status is valid, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create a list of P1 issues created by user USR-321 and summarize them[/INST]","var_1 = search_object_by_name(query=""USR-321"")
var_2 = works_list(type=[""issue""], issue.priority=[""p1""], created_by=[var_1])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_tasks_by_due_date(task_ids, due_date):
""""""
Filters tasks by their due date

Parameters:
    task_ids (list): A list of task IDs to filter
    due_date (str): The due date to filter tasks by

Returns:
    list: List of task IDs that have the specified due date
""""""

def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""


def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def link_related_documents(doc_id, related_doc_ids):
""""""
Links related documents to the given document in the system

Parameters:
    doc_id (str): The ID of the document to which related documents should be linked
    related_doc_ids (list): A list of IDs for related documents

Returns:
    bool: True if the operation was successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def check_availability_of_part(part_id):
""""""
Checks if a specific part is available in inventory

Parameters:
    part_id (str): The ID of the part to check for availability

Returns:
    bool: True if the part is available, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize issues reported by 'ClientA' and create tasks for any p0 priority issues mentioned in their feedback.[/INST]","var_1 = search_object_by_name(query=""ClientA"")
var_2 = works_list(created_by=[var_1], type=[""issue""])
var_3 = prioritize_objects(objects=var_2)
var_4 = create_actionable_tasks_from_text(text=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def find_work_items_by_tag(work_type, tag):
""""""
Finds work items of a certain type with a given tag

Parameters:
    work_type (str): The type of the work items to filter by
    tag (str): The tag to filter the work items

Returns:
    list: List of work items with the given tag
""""""


def convert_task_to_ticket(task_id):
""""""
Converts a task into a ticket in the system

Parameters:
    task_id (str): The ID of the task to be converted

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def archive_completed_tasks(project_id, completed_since):
""""""
Archives tasks that are completed within the given project since the specified time

Parameters:
    project_id (str): The ID of the project containing the tasks
    completed_since (str): Archive tasks completed after this timestamp

Returns:
    int: Number of tasks archived
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def deactivate_user_account(user_id, reason):
""""""
Deactivates a user account for a specific reason

Parameters:
    user_id (str): The ID of the user whose account is to be deactivated
    reason (str): The reason for deactivating the account

Returns:
    bool: True if the account was successfully deactivated; otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_work_left(project_id):
""""""
Calculates the estimated amount of work left in a project

Parameters:
    project_id (str): The ID of the project to calculate work for

Returns:
    float: Estimated hours of work left
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_stage_of_work_item(work_item_id, new_stage):
""""""
Updates the stage of a work item

Parameters:
    work_item_id (str): The ID of the work item to update
    new_stage (str): The new stage to which the work item should be moved

Returns:
    bool: True if the stage is successfully updated, False otherwise
""""""


def generate_progress_report(project_id):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which to generate the report

Returns:
    str: A string summary of the project's progress report
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What if the concept of good and evil is a dynamic balance rather than a fixed dichotomy?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_ticket_comments(ticket_id):
""""""
Retrieves the comments attached to a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose comments are being retrieved

Returns:
    list: Comments associated with the ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def mark_ticket_as_resolved(ticket_id):
""""""
Marks a ticket as resolved in the system

Parameters:
    ticket_id (str): The ID of the ticket to be marked as resolved

Returns:
    bool: True if the ticket was marked as resolved, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def update_user_ID(user_id, status):
""""""
Updates the status of a user account in the system and returns the updated id

Parameters:
    user_id (str): The ID of the user whose status is to be updated
    status (str): The new status to apply to the user account

Returns:
    str: updated User Id
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def list_user_permissions(user_id):
""""""
Lists all the permissions that a user has within the system

Parameters:
    user_id (str): The ID of the user for whom permissions are being listed

Returns:
    list: A list of permissions that the user possesses
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Prioritize tasks for ""User-321"" and filter by type ""issue""[/INST]","var_1 = who_am_i()
var_2 = works_list(created_by=[""User-321""], type=[""issue""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def notify_user_of_overdue_tasks(user_id):
""""""
Notifies a user of any overdue tasks assigned to them

Parameters:
    user_id (str): The ID of the user to check for overdue tasks

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def get_recent_activity_log(user_id, limit=10):
""""""
Gets the most recent activity log entries for a given user

Parameters:
    user_id (str): The ID of the user to get activities for
    limit (int): The maximum number of activity log entries to return

Returns:
    list: Recent activity log entries
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify my tasks, filter for tasks at 'review' stage, and return them in order of priority.[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""review""], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def link_related_objects(object_id, related_object_id):
""""""
Creates a link between two related objects in the system

Parameters:
    object_id (str): The ID of the primary object
    related_object_id (str): The ID of the object to relate to the primary

Returns:
    bool: True if the objects were successfully linked, False otherwise
""""""


def remove_object_from_archive(object_id):
""""""
Removes an object from the system archive, making it active again

Parameters:
    object_id (str): The ID of the object to be removed from the archive

Returns:
    bool: True if the object was successfully removed, False otherwise
""""""


def remove_object_from_sprint(object_id, sprint_id):
""""""
Removes a specified object from a sprint and returns the new list

Parameters:
    object_id (str): The ID of the object to be removed
    sprint_id (str): The ID of the project from which the object should be removed

Returns:
    list: Returns the updated list of sprint objects
""""""


def get_user_contact_info(user_id):
""""""
Retrieves contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact information is requested

Returns:
    str: The contact information of the user
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def calculate_estimate_completion_time(work_id):
""""""
Calculates the estimated completion time for the specified work item

Parameters:
    work_id (str): The ID of the work item to calculate the estimated time

Returns:
    float: Estimated completion time in hours
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Summarize the work items for 'Client-X' and identify the most critical tasks to address.[/INST]","var_1 = search_object_by_name(query=""Client-X"")
var_2 = works_list(created_by=[var_1])
var_3 = summarize_objects(objects=var_2)
var_4 = prioritize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def generate_report_for_sprint(sprint_id):
""""""
Generates a performance report for a specified sprint

Parameters:
    sprint_id (str): The ID of the sprint for which to generate the report

Returns:
    str: The ID of the generated report
""""""


def estimate_completion_time(task_id):
""""""
Estimates the completion time for a given task

Parameters:
    task_id (str): The ID of the task for which to estimate completion time

Returns:
    float: The estimated number of hours to complete the task
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def fetch_user_created_work(user_id, work_type=None):
""""""
Retrieves work items created by a specific user

Parameters:
    user_id (str): The ID of the user whose work items are to be retrieved
    work_type (list): Filters for work of the provided types, e.g., ['issue', 'ticket']

Returns:
    list: Work items created by the user
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def list_work_attachments(work_id):
""""""
Lists all attachments associated with a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: Attachment file IDs
""""""


def get_team_member_list(team_id):
""""""
Retrieves a list of team members for the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: List of team member IDs
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify the current sprint ID and add issues with priority p2 to it[/INST]","var_1 = get_sprint_id()
var_2 = works_list(issue.priority=[""p2""], type=[""issue""])
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def assign_tasks_to_employee(task_ids, employee_id):
""""""
Assigns a list of tasks to the specified employee

Parameters:
    task_ids (list): A list of task IDs to be assigned
    employee_id (str): The ID of the employee to whom the tasks will be assigned

Returns:
    bool: True if the assignment was successful, False otherwise
""""""


def calculate_workload_for_user(user_id):
""""""
Calculates the total number of open work items assigned to a user

Parameters:
    user_id (str): The ID of the user for whom to calculate the workload

Returns:
    int: The total number of open work items
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def deactivate_user_account(user_id, reason):
""""""
Deactivates a user account for a specific reason

Parameters:
    user_id (str): The ID of the user whose account is to be deactivated
    reason (str): The reason for deactivating the account

Returns:
    bool: True if the account was successfully deactivated; otherwise False
""""""


def calculate_estimate_completion_time(work_id):
""""""
Calculates the estimated completion time for the specified work item

Parameters:
    work_id (str): The ID of the work item to calculate the estimated time

Returns:
    float: Estimated completion time in hours
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""

def retrieve_sprint_workload(sprint_id):
""""""
Calculates the total workload for a given sprint based on the work items associated with it

Parameters:
    sprint_id (str): The ID of the sprint for workload calculation

Returns:
    float: Total workload in hours
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create tasks for issues that need response and are created by user USR-456[/INST]","var_1 = works_list(ticket.needs_response=True, created_by=[""USR-456""], type=[""issue""])
var_2 = create_actionable_tasks_from_text(text=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def merge_duplicate_work_items(primary_work_id, duplicate_work_ids):
""""""
Merges duplicate work items into the primary work item

Parameters:
    primary_work_id (str): The ID of the primary work item
    duplicate_work_ids (list): List of IDs of duplicate work items to be merged

Returns:
    bool: True if merge was successful, otherwise False
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def filter_projects_by_status(project_ids, status=""active""):
""""""
Filters a list of project IDs by their status

Parameters:
    project_ids (list): A list of project IDs to filter
    status (str): The status to filter by, default is 'active'

Returns:
    list: Project IDs matching the status
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Get a summary of all my issues that are currently in the 'Development' stage[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""Development""], type=[""issue""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def estimate_completion_time(task_id):
""""""
Estimates the completion time for a given task

Parameters:
    task_id (str): The ID of the task for which to estimate completion time

Returns:
    float: The estimated number of hours to complete the task
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def assign_issues_to_user(issue_ids, user_id):
""""""
Assigns a list of issues to the specified user

Parameters:
    issue_ids (list): A list of issue IDs that need to be assigned
    user_id (str): The user ID to whom the issues will be assigned

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Add my tickets with 'blocker' severity to the current sprint[/INST]","var_1 = who_am_i()
var_2 = works_list(type=[""ticket""], owned_by=[var_1], ticket.severity=[""blocker""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def deactivate_user_account(user_id, reason):
""""""
Deactivates a user account for a specific reason

Parameters:
    user_id (str): The ID of the user whose account is to be deactivated
    reason (str): The reason for deactivating the account

Returns:
    bool: True if the account was successfully deactivated; otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve and summarize all low severity tickets from the Rev organization REV-456[/INST]","var_1 = works_list(issue.rev_orgs=[""REV-456""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
         Retrieve similar work items to TASK-234, summarize them, and limit the number of work items to 50.[/INST]","var_1 = get_similar_work_items(work_id=""TASK-234"")
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def filter_tasks_by_due_date(task_ids, due_date):
""""""
Filters tasks by their due date

Parameters:
    task_ids (list): A list of task IDs to filter
    due_date (str): The due date to filter tasks by

Returns:
    list: List of task IDs that have the specified due date
""""""



def generate_progress_report(project_id, report_format=""summary""):
""""""
Generates a progress report for the specified project

Parameters:
    project_id (str): The ID of the project for which the progress report is needed
    report_format (str): The format of the report; 'summary' or 'detailed'. The default is 'summary'

Returns:
    str: The generated progress report
""""""


def create_new_ticket(title, description, reported_by):
""""""
Creates a new ticket in the system with the given details

Parameters:
    title (str): The title of the new ticket
    description (str): A detailed description of the issue or request
    reported_by (str): The ID of the user reporting the ticket

Returns:
    str: The ID of the newly created ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def notify_user_of_overdue_tasks(user_id):
""""""
Notifies a user of any overdue tasks assigned to them

Parameters:
    user_id (str): The ID of the user to check for overdue tasks

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""


def batch_update_user_roles(user_ids, new_role):
""""""
Updates the roles for a batch of users to a new role

Parameters:
    user_ids (list): List of user IDs whose roles should be updated
    new_role (str): The new role to assign

Returns:
    int: Number of users successfully updated
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def update_contact_info(contact_id, new_email=None, new_phone=None):
""""""
Updates the contact information for a given contact ID with new email and/or phone

Parameters:
    contact_id (str): The ID of the contact to update
    new_email (str, optional): The new email address; defaults to None
    new_phone (str, optional): The new phone number; defaults to None

Returns:
    bool: True if the update was successful; otherwise False
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def merge_duplicate_tickets(primary_ticket_id, duplicate_ticket_ids):
""""""
Merges duplicate tickets into a primary ticket

Parameters:
    primary_ticket_id (str): The ID of the primary ticket that remains
    duplicate_ticket_ids (list): The IDs of the duplicate tickets to be merged into the primary

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify and add all unresolved issues from the ""Backend"" team to the upcoming sprint.[/INST]","var_1 = search_object_by_name(query=""Backend"")
var_2 = works_list(issue.rev_orgs=[var_1], type=[""issue""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_contact_info(user_id):
""""""
Retrieves the contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact info is requested

Returns:
    str: Contact information of the user
""""""


def calculate_budget_remaining(budget_id):
""""""
Calculates the remaining budget for a given budget ID

Parameters:
    budget_id (str): The ID of the budget to calculate

Returns:
    float: The amount of remaining budget
""""""
def merge_ticket_notes(ticket_id, note_ids, updated_by):
""""""
Merges multiple notes into a single ticket note

Parameters:
    ticket_id (str): The ID of the ticket where the merged note will be added
    note_ids (list): List of note IDs that will be merged into the ticket
    updated_by (str): The ID of the user performing the merge

Returns:
    str: ID of the updated ticket note
""""""


def check_object_permission(user_id, object_id):
""""""
Checks if a user has permission to access a specific object

Parameters:
    user_id (str): The ID of the user
    object_id (str): The ID of the object to check permission for

Returns:
    bool: True if the user has permission, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def list_user_skills(user_id):
""""""
Lists the skills associated with the specified user

Parameters:
    user_id (str): The ID of the user whose skills are being queried

Returns:
    list: The skills of the user
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve work items of type 'issue' from Rev organization 'REV-999' and summarize them[/INST]","var_1 = works_list(issue.rev_orgs=[""REV-999""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def estimate_cost_for_work(work_id, cost_per_hour=100):
""""""
Estimates the cost for completing a work item based on a cost per hour rate

Parameters:
    work_id (str): The ID of the work item to estimate cost for
    cost_per_hour (float): The cost per hour. Default is '100'

Returns:
    float: Estimated cost
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def validate_data_integrity(data_point_ids):
""""""
Checks the integrity of a list of data points in the system

Parameters:
    data_point_ids (list): List of data point IDs to validate

Returns:
    list: Validation results with status (True or False) for each data point
""""""


def extend_sprint_end_date(sprint_id, new_end_date):
""""""
Extends the end date of a current sprint to a new date

Parameters:
    sprint_id (str): The ID of the sprint to extend
    new_end_date (str): The new end date for the sprint in YYYY-MM-DD format

Returns:
    bool: True if the sprint end date was extended, False otherwise
""""""


def validate_work_item_completeness(work_id):
""""""
Checks if a work item has all necessary information completed

Parameters:
    work_id (str): The ID of the work item to check

Returns:
    bool: True if the work item is complete, False if it lacks information
""""""
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task is assigned

Returns:
    None
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify and add work items requiring a response to the ""Urgent-Queries"" sprint[/INST]","var_1 = search_object_by_name(query=""Urgent-Queries"")
var_2 = works_list(ticket.needs_response=True, type=[""work""])
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def retrieve_user_contact_info(user_id):
""""""
Retrieves the contact information for a user

Parameters:
    user_id (str): The ID of the user whose contact info is requested

Returns:
    str: Contact information of the user
""""""


def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def update_object_status(object_id, new_status, changed_by):
""""""
Updates the status of an object and records the user that made the change

Parameters:
    object_id (str): The ID of the object for which the status is updated
    new_status (str): The new status for the object
    changed_by (str): The ID of the user who is changing the status

Returns:
    None
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def generate_unique_identifier(prefix, use_timestamp=True):
""""""
Generates a unique identifier with an optional timestamp

Parameters:
    prefix (str): A prefix for the identifier
    use_timestamp (bool): If true, appends a timestamp to the prefix; defaults to True

Returns:
    str: The generated unique identifier
""""""


def filter_users_by_skill(skill_name, minimum_proficiency=3):
""""""
Filters users by a specific skill and its minimum proficiency level

Parameters:
    skill_name (str): The name of the skill to filter by
    minimum_proficiency (int): The minimum proficiency level a user should have in the skill

Returns:
    list: A list of user IDs that match the criteria
""""""


def check_availability_of_part(part_id):
""""""
Checks if a specific part is available in inventory

Parameters:
    part_id (str): The ID of the part to check for availability

Returns:
    bool: True if the part is available, False otherwise
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and summarize work items related to project Alpha123[/INST]","var_1 = search_object_by_name(query=""Alpha123"")
var_2 = works_list(applies_to_part=[var_1], type=[""issue"", ""ticket"", ""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def estimate_ticket_resolution_time(ticket_id):
""""""
Estimates the resolution time for a given ticket

Parameters:
    ticket_id (str): The ID of the ticket to estimate time for

Returns:
    float: Estimated time in hours to resolve the ticket
""""""


def update_work_item_status(work_item_id, new_status):
""""""
Updates the status of a given work item

Parameters:
    work_item_id (str): The ID of the work item to be updated
    new_status (str): The new status to set for the work item
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Locate and summarize my tasks that need responses within the 'customer_support' stage[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], stage.name=[""customer_support""], ticket.needs_response=True, type=[""task""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find and prioritize tasks from customer feedback file and summarize the prioritized list[/INST]","var_1 = create_actionable_tasks_from_text(text=""customer feedback file"")
var_2 = prioritize_objects(objects=var_1)
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""

def assign_tickets_to_user(ticket_ids, user_id):
""""""
Assigns a set of tickets to a specified user

Parameters:
    ticket_ids (list): A list of ticket IDs to be assigned
    user_id (str): The ID of the user to whom the tickets will be assigned

Returns:
    None
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Extract tasks from meeting notes ""MeetingNotes-1234"" and summarize for project management review[/INST]","var_1 = create_actionable_tasks_from_text(text=""MeetingNotes-1234"")
var_2 = summarize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def update_issue_with_solution(issue_id, solution_text):
""""""
Updates an issue with a solution description

Parameters:
    issue_id (str): The ID of the issue to be updated
    solution_text (str): The description of the solution to apply to the issue

Returns:
    None
""""""


def remove_user_from_project(user_id, project_id):
""""""
Removes a user from a project

Parameters:
    user_id (str): The ID of the user to be removed
    project_id (str): The ID of the project from which the user is to be removed

Returns:
    bool: True if the user is successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def archive_completed_tasks(project_id, completed_since):
""""""
Archives tasks that are completed within the given project since the specified time

Parameters:
    project_id (str): The ID of the project containing the tasks
    completed_since (str): Archive tasks completed after this timestamp

Returns:
    int: Number of tasks archived
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def list_all_blocked_tickets():
""""""
Lists all tickets that are currently blocked

Returns:
    list: Ticket IDs that are currently blocked
""""""


def generate_project_summary(project_id):
""""""
Generates a summary report for the specified project

Parameters:
    project_id (str): The ID of the project to summarize

Returns:
    str: A summary report of the project
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def generate_summary_report(object_ids):
""""""
Generates a summary report for the specified objects

Parameters:
    object_ids (list): A list of object IDs

Returns:
    str: The ID of the generated report
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find issues for component COMP-321 and order them by urgency[/INST]","var_1 = works_list(applies_to_part=[""COMP-321""], type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def get_ticket_comments(ticket_id):
""""""
Retrieves the comments attached to a ticket

Parameters:
    ticket_id (str): The ID of the ticket whose comments are being retrieved

Returns:
    list: Comments associated with the ticket
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def track_project_completion(project_id):
""""""
Tracks the completion percentage of a project based on completed tasks

Parameters:
    project_id (str): The ID of the project to track

Returns:
    float: Percentage of the project completed
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def calculate_estimated_effort(work_id):
""""""
Calculates the estimated effort required to complete a work item.

Parameters:
    work_id (str): The ID of the work item

Returns:
    float: Estimated effort in hours
""""""


def get_user_avatar(user_id):
""""""
Retrieves the avatar image URL for the specified user

Parameters:
    user_id (str): The ID of the user whose avatar is to be retrieved

Returns:
    str: URL of the user's avatar image
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Get tickets needing response, sort them by priority and assign them to the sprint with ID ""SPRINT-321""[/INST]","var_1 = works_list(type=[""ticket""], ticket.needs_response=True)
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2, sprint_id=""SPRINT-321"")
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        What if there are alternate versions of ourselves living in parallel universes?[/INST]",#Unanswerable_Invalid_Query_Error
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def convert_task_to_subtask(task_id, parent_task_id):
""""""
Converts a standalone task into a subtask of another task

Parameters:
    task_id (str): The ID of the task to be converted
    parent_task_id (str): The ID of the parent task to which the subtask will be linked

Returns:
    bool: True if the conversion was successful, False otherwise
""""""


def merge_duplicate_tasks(primary_task_id, duplicate_task_ids):
""""""
Merges duplicate tasks into a primary task

Parameters:
    primary_task_id (str): The ID of the primary task which remains after the merge
    duplicate_task_ids (list): A list of IDs of the duplicate tasks to be merged

Returns:
    None
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

def assign_ticket_to_user(ticket_id, user_id):
""""""
Assigns a specific ticket to a user

Parameters:
    ticket_id (str): The ID of the ticket to be assigned
    user_id (str): The ID of the user to whom the ticket will be assigned

Returns:
    bool: True if the assignment is successful, False otherwise
""""""

def who_am_i():
""""""
Returns the string ID of the current user
""""""



def merge_duplicate_records(primary_record_id, duplicate_record_id):
""""""
Merges a duplicate record into a primary record

Parameters:
    primary_record_id (str): The ID of the primary record to keep
    duplicate_record_id (str): The ID of the duplicate record to merge

Returns:
    bool: True if the merge was successful; otherwise False
""""""

def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def get_work_item_history(work_id):
""""""
Retrieves the history of changes for a given work item

Parameters:
    work_id (str): The ID of the work item

Returns:
    list: A chronological list of changes made to the work item
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def update_contact_info(contact_id, new_email=None, new_phone=None):
""""""
Updates the contact information for a given contact ID with new email and/or phone

Parameters:
    contact_id (str): The ID of the contact to update
    new_email (str, optional): The new email address; defaults to None
    new_phone (str, optional): The new phone number; defaults to None

Returns:
    bool: True if the update was successful; otherwise False
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For the user currently logged in, retrieve the list of tickets with medium severity and summarize.[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], ticket.severity=[""medium""], type=[""ticket""])
var_3 = summarize_objects(objects=var_2)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        

def assign_tasks_to_employee(task_ids, employee_id):
""""""
Assigns a list of tasks to the specified employee

Parameters:
    task_ids (list): A list of task IDs to be assigned
    employee_id (str): The ID of the employee to whom the tasks will be assigned

Returns:
    bool: True if the assignment was successful, False otherwise
""""""


def remove_user_from_project(user_id, project_id):
""""""
Removes a user from a project

Parameters:
    user_id (str): The ID of the user to be removed
    project_id (str): The ID of the project from which the user is to be removed

Returns:
    bool: True if the user is successfully removed, False otherwise
""""""
         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Identify and add all blocker tickets to the sprint for ""ComponentZ""[/INST]","var_1 = search_object_by_name(query=""ComponentZ"")
var_2 = works_list(ticket.severity=[""blocker""], type=[""ticket""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
                 
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""



def calculate_time_until_deadline(work_item_id):
""""""
Calculates the amount of time remaining until the deadline of a work item

Parameters:
    work_item_id (str): The ID of the work item

Returns:
    float: The number of hours until the deadline
""""""


def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""



def generate_summary_report(object_ids):
""""""
Generates a summary report for the specified objects

Parameters:
    object_ids (list): A list of object IDs

Returns:
    str: The ID of the generated report
""""""

def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""



def calculate_cost_of_tasks(task_ids):
""""""
Calculates the total cost for a list of task IDs

Parameters:
    task_ids (list): A list of task IDs to calculate cost for

Returns:
    float: Total cost of the tasks
""""""

def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""



def retrieve_document_by_keyword(keyword):
""""""
Retrieves a document ID containing the specified keyword

Parameters:
    keyword (str): The keyword to search for in the documents

Returns:
    str: ID of the document containing the keyword
""""""Here are some sample queries         and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find all P2 issues I own, add them to my sprint, and summarize the sprint contents[/INST]","var_1 = who_am_i()
var_2 = works_list(owned_by=[var_1], issue.priority=[""p2""], type=[""issue""])
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)
var_5 = summarize_objects(objects=var_2)
"
