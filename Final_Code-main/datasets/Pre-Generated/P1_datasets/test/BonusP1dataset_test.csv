Query,Output
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve work items with type ""ticket"" and severity ""high"", summarize them, and assign the first 10 to user USER-123.[/INST]","var_1 = works_list(type=[""ticket""], ticket.severity=[""high""])
var_2 = summarize_objects(objects=var_1)
var_3 = search_object_by_name(query=""USER-123"")
for loop_var in range(0, 10):
     temp_1 = assign_task_to_user(task_id=var_1[loop_var], user_id=var_3)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items with priority ""p1"" and type ""issue"", prioritize them, and add the top 3 to sprint SPRINT-321.[/INST]","var_1 = works_list(issue.priority=[""p1""], type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = search_object_by_name(query=""SPRINT-321"")
var_4 = add_work_items_to_sprint(work_ids=var_2[0:3], sprint_id=var_3)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Extract tasks from the text ""ReleaseNotes"", prioritize them, and assign the first 5 to the current sprint.[/INST]","var_1 = create_actionable_tasks_from_text(text=""ReleaseNotes"")
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=var_3)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        For all tickets with source channel ""email"", prioritize them, and assign the most critical one to the current sprint.[/INST]","var_1 = works_list(ticket.source_channel=[""email""], type=[""ticket""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=[var_2[0]], sprint_id=var_3)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items owned by USER-222, summarize them, and estimate the work hours for each item.[/INST]","var_1 = search_object_by_name(query=""USER-222"")
var_2 = works_list(owned_by=[var_1])
var_3 = summarize_objects(objects=var_2)
for loop_var in var_2:
    temp_1 = estimate_work_hours(work_id=loop_var)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Retrieve all tasks created by USER-333, prioritize them, and assign the one with the highest priority to USER-444.[/INST]","var_1 = search_object_by_name(query=""USER-333"")
var_2 = works_list(created_by=[var_1], type=[""task""])
var_3 = prioritize_objects(objects=var_2)
var_4 = search_object_by_name(query=""USER-444"")
var_5 = assign_task_to_user(task_id=var_3[0], user_id=var_4)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Extract tasks from the text ""ClientFeedback"", create a report of type ""A"" for each task without including summary, and assign the tasks to USER-555.[/INST]","var_1 = create_actionable_tasks_from_text(text=""ClientFeedback"")
var_2 = search_object_by_name(query = ""USER-555"")
for loop_var in var_1:
    temp_1 = generate_report(report_type=""A"", subject_id=loop_var, include_summary=False)
    temp_2 = assign_task_to_user(task_id=loop_var, user_id=var_2)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Create tasks from the text ""ClientMeetingSummary"", prioritize them, and assign the first 3 to user USER-999.[/INST]","var_1 = create_actionable_tasks_from_text(text=""ClientMeetingSummary"")
var_2 = prioritize_objects(objects=var_1)
var_3 = search_object_by_name(query=""USER-999"")
for loop_var in range(0,3):
    temp_1 = assign_task_to_user(task_id=var_2[loop_var], user_id=var_3)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Find work items related to part PART-234, summarize them, and estimate the work hours for each.[/INST]","var_1 = search_object_by_name(query=""PART-234"")
var_2 = works_list(applies_to_part=[var_1])
var_3 = summarize_objects(objects=var_2)
for loop_var in var_2:
    temp_1 = estimate_work_hours(work_id=loop_var)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Extract tasks from the text ""DevelopmentPlan"", prioritize them, and assign them to the current sprint.[/INST]","var_1 = create_actionable_tasks_from_text(text=""DevelopmentPlan"")
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
var_4 = add_work_items_to_sprint(work_ids=var_2, sprint_id=var_3)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Get similar work items to ISSUE-345, summarize them, and assign the most critical one to USER-1111.[/INST]","var_1 = search_object_by_name(query=""ISSUE-345"")
var_2 = get_similar_work_items(work_id=var_1)
var_3 = summarize_objects(objects=var_2)
var_4 = prioritize_objects(objects=var_2)
var_5 = search_object_by_name(query=""USER-1111"")
var_6 = assign_task_to_user(task_id=var_4[0], user_id=var_5)"
"<s> [INST] <<SYS>>\nYou are a helpful and faithful coding assistant. You follow the given instructions            meticulously and ensure an efficient interaction by prioritizing user needs.\n<</SYS>>\n\n
        The only code you know to write is of type ""var_i = function_call(function_argument)"", where i is the ith variable in use.        You never output anything else other than this format. You follow the sequence of completing query religiously.
        You have a given set of functions and you must use them to answer the query. You are not allowed to use any other functions.
        Here are the allowed functions-
        ''
def estimate_work_hours(work_id):
""""""
Estimates the number of hours required to complete a specific work item

Parameters:
    work_id (str): The ID of the work item for which the estimation is to be made

Returns:
    float: Estimated hours required to complete the work item
""""""
''',
'''
def assign_task_to_user(task_id, user_id):
""""""
Assigns a specific task to a user

Parameters:
    task_id (str): The ID of the task to be assigned
    user_id (str): The ID of the user to whom the task will be assigned

Returns:
    bool: True if assignment was successful, otherwise False
""""""
'''
''
def generate_report(report_type, subject_id, include_summary=True):
""""""
Generates a report of a specific type for a subject in the system

Parameters:
    report_type (str): The type of report to generate
    subject_id (str): The ID of the subject for the report
    include_summary (bool): Whether to include a summary in the report; defaults to True

Returns:
    str: The ID of the generated report
""""""
'''
''
def delete_object_by_id(object_id):
""""""
Deletes object from the system based on its ID
Parameters:
    object_id : Object ID to delete

Returns:
    bool: True if objects were successfully deleted, False otherwise
""""""
'''
''
def mark_task_as_completed(task_id):
""""""
Marks a task as completed in the system.

Parameters:
 task_id (str): The ID of the task to be marked as complete

Returns:
 bool: True if marked successfully, False otherwise
""""""

def works_list(applies_to_part=None, created_by=None, issue.priority=None, issue.rev_orgs=None, limit=50, owned_by=None, stage.name=None, ticket.needs_response=False, ticket.rev_org=None, ticket.severity=None, ticket.source_channel=None, work_type=None):
""""""
Returns a list of work items matching the request

Parameters:
    applies_to_part (list): Filters for work belonging to any of the provided parts
    created_by (list): Filters for work created by any of these users
    issue.priority (list): Filters for issues with any of the provided priorities. Allowed values: p0, p1, p2, p3
    issue.rev_orgs (list): Filters for issues with any of the provided Rev organizations
    limit (int): The maximum number of works to return. The default is '50'
    owned_by (list): Filters for work owned by any of these users
    stage.name (list): Filters for records in the provided stage(s) by name
    ticket.needs_response (bool): Filters for tickets that need a response
    ticket.rev_org (list): Filters for tickets associated with any of the provided Rev organizations
    ticket.severity (list): Filters for tickets with any of the provided severities. Allowed values: blocker, high, low, medium
    ticket.source_channel (list): Filters for tickets with any of the provided source channels
    type (list): Filters for work of the provided types. Allowed values: issue, ticket, task

Returns:
    list: Matching work items
""""""

         
def summarize_objects(objects):
""""""
Summarizes a list of objects. The logic of how to summarize a particular object type is an internal implementation detail

Parameters:
    objects (list): List of objects to summarize

Returns:
    text: Summarized text of the objects
""""""


def create_actionable_tasks_from_text(text):
""""""
Given a text, extracts actionable insights, and creates tasks for them, which are kind of a work item

Parameters:
    text (str): The text from which the actionable insights need to be created

Returns:
    list: tasks created from the given text
""""""


def search_object_by_name(query):
""""""
Given a search string, returns the ID of a matching object in the system of record. If multiple matches are found, it returns the one where the confidence is highest

Parameters:
    query (str): The search string, could be for example customer’s name, part name, user name

Returns:
    str: ID of matching object
""""""

''
def find_team_members(team_id):
""""""
Returns a list of user IDs that are members of the specified team

Parameters:
    team_id (str): The ID of the team

Returns:
    list: User IDs of the team members
""""""
'''

def who_am_i():
""""""
Returns the string ID of the current user
""""""


def get_similar_work_items(work_id):
""""""
Returns a list of work items that are similar to the given work item

Parameters:
    work_id (str): The ID of the work item for which you want to find similar items

Returns:
    list: Similar work items
""""""


def prioritize_objects(objects):
""""""
Returns a list of objects sorted by priority. The logic of what constitutes priority for a given object is an internal implementation detail

Parameters:
    objects (list): A list of objects to be prioritized

Returns:
    list: Prioritized objects
""""""


def add_work_items_to_sprint(work_ids, sprint_id):
""""""
Adds the given work items to the sprint

Parameters:
    work_ids (list): A list of work item IDs to be added to the sprint
    sprint_id (str): The ID of the sprint to which the work items should be added
""""""


def get_sprint_id():
""""""
Returns the ID of the current sprint
""""""
If the query requires the use of conditional logic or iterations, use if, else or for loop,          in the same format shown in the examples below. In case of a condition or loop, use temp_x in place of var_i inside the block, where x           is an integer starting from 1, denoting the index of variable.Do not use temp except in case of a condition or iteration. Variables var_i           cannot be called inside the block, only temp_x variables can be used as function arguments in this case. The format is as follows-            if (<condition>):                temp_1 = function_call(function_argument)                temp_2 = ...             else:                temp_1 = function_call(function_argument)                temp_2 = ...            for loop_var in <list or range only>:                temp_1 = function_call(function_argument)                temp_2 = ...          Here are some sample queries and their respective responses:1. query: Get and summarize all tasks in the 'completed' stage owned by the current user, then prioritize them.
1. output:
var_1 = who_am_i()
var_2 = works_list(stage.name = ['completed'], owned_by = var1)
var_3 = summarize_objects(objects = var2)
var_4 = prioritize_objects(objects = var3)

2. query: Retrieve and summarize all tickets marked as blocker severity associated with ""REV-Engineering""
2. output:
var_1 = search_object_by_name(query=""REV-Engineering"")
var_2 = works_list(ticket.severity=[""blocker""], ticket.rev_org=[var_1])
var_3 = summarize_objects(objects=var_2)

3. query: Generate a list of my P1 and P2 issues and create action items for them
3. output:
var_1 = who_am_i()
var_2 = works_list(issue.priority=[""p1"", ""p2""], owned_by=[var_1], type=[""issue""])
var_3 = create_actionable_tasks_from_text(text=var_2)

4. Query: Identify work items of type 'issue' that need to be added to sprint with ID SPRINT-678.
4. Output: var_1 = works_list(type=[""issue""])
var_2 = add_to_sprint(objects=var_1, sprint_id=[""SPRINT-678""])

5. Query: Summarize and prioritize issues created by user USER-XYZ
5. Output:
var_1 = works_list(created_by=[""USER-XYZ""], type=[""issue""])
var_2 = summarize_objects(objects=var_1)
var_3 = prioritize_objects(objects=var_2)

6 Query: Find work items of type ""issue"" that need a response, prioritize them, and assign the top 5 to the current sprint.
6. Output:
var_1 = works_list(ticket.needs_response=True, type=[""issue""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()
for loop_var in range(0,5):
    temp_1 = add_work_items_to_sprint(work_ids=[var_2[loop_var]], sprint_id=var_3)

7. Query: Extract tasks from the text ""EngineeringSpecs"", prioritize them, and add the top 5 to the sprint with ID ""SPRINT-ENGINEERING"".
7. Output:
var_1 = create_actionable_tasks_from_text(text=""EngineeringSpecs"")
var_2 = prioritize_objects(objects=var_1)
var_3 = add_work_items_to_sprint(work_ids=var_2[0:5], sprint_id=""SPRINT-ENGINEERING"")

8. Query: Find all tickets with source channel ""web"" and severity ""low"", summarize them, and if the current sprint is ""SprintCleanup"", add all tickets to it; otherwise, create a new sprint and add them there.
8. Output:
var_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
var_2 = summarize_objects(objects=var_1)
var_3 = get_sprint_id()
if(var_3 == ""SprintCleanup""):
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=""SprintCleanup"")
else:
    temp_1 = works_list(ticket.source_channel=[""web""], ticket.severity=[""low""], type=[""ticket""])
    temp_2 = create_actionable_tasks_from_text(text=""Create New Sprint"")
    temp_3 = add_work_items_to_sprint(work_ids=temp_1, sprint_id=temp_2)

9. Query: Find work items associated with feature PROD-999, prioritize them, and get the sprint ID
9. Output:
var_1 = works_list(applies_to_part=[""PROD-999""])
var_2 = prioritize_objects(objects=var_1)
var_3 = get_sprint_id()

10. Query: Identify my tasks related to the ""X1-Project"" and summarize them
10. Output:
var_1 = who_am_i()
var_2 = search_object_by_name(query=""X1-Project"")
var_3 = works_list(owned_by=[var_1], applies_to_part=[var_2], type=[""task""])
var_4 = summarize_objects(objects=var_3)
        Answer very strictly in the same format shown above. Make sure to mention type argument wherever relevant when calling works_list.        Any missing type arguments is not acceptable. Don't make unnecessary calls to any functions. When given names make sure to call         search_object_by_name() to get work_ids. Ensure logical continuity at each step. Ensure that the query is answered fully.
        You are not allowed to nest function calls. You are not allowed to output ""python"" or any other statement apart from the given format.
        Do not use any other format for output than the one given above. Do not put any comment in your answer. Anything else other         than the format specified is not acceptable. Do not define any new helper functions or any other python functions apart from         the ones provided.

        Do not output any text apart from the final output code.
        If you are unable to answer a query, you can output ""Unanswerable_query_error"".
        Answer the query:
        Search for the object ID with the name ""ProjectAlpha"" and generate a report for it, including a summary.[/INST]","var_1 = search_object_by_name(query=""ProjectAlpha"")
var_2 = generate_report(report_type=""object"", subject_id=var_1, include_summary=True)"
